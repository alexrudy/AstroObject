
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>AstroObject.AnalyticSpectra &mdash; AstroObject 0.5.3 documentation</title>
    
    <link rel="stylesheet" href="../../_static/nature.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '0.5.3',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="top" title="AstroObject 0.5.3 documentation" href="../../index.html" />
    <link rel="up" title="AstroObject" href="../AstroObject.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../index.html">AstroObject 0.5.3 documentation</a> &raquo;</li>
          <li><a href="../index.html" >Module code</a> &raquo;</li>
          <li><a href="../AstroObject.html" accesskey="U">AstroObject</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <h1>Source code for AstroObject.AnalyticSpectra</h1><div class="highlight"><pre>
<span class="c"># -*- coding: utf-8 -*-</span>
<span class="c"># </span>
<span class="c">#  AnalyticSpectra.py</span>
<span class="c">#  ObjectModel</span>
<span class="c">#  </span>
<span class="c">#  Created by Alexander Rudy on 2011-10-12.</span>
<span class="c">#  Copyright 2011 Alexander Rudy. All rights reserved.</span>
<span class="c">#  Version 0.5.3</span>
<span class="c"># </span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">:mod:`AnalyticSpectra` – Analytic Spectra and Interpolation</span>
<span class="sd">===========================================================</span>

<span class="sd">Objects for manipulating and managing spectra which are inherently analytic (i.e. you want interpolation, or your spectrum to be defined by a single function). The classes provided in this module are *FRAMES* not *OBJECTS*, i.e. they are individual representations of spectra etc.</span>

<span class="sd">It is possible to create an AnalyticSpectraObject to hold many spectra. However, such an object might be of limited utility, as it could not be used to write or read data saved in FITS files, as the FITS format is not conducive to storing analytic items.</span>

<span class="sd">.. Note::</span>
<span class="sd">    This is a solvable problem. I could use FITS header information to store the required values for an analytic spectrum, and then simply store empty images. However, I don&#39;t need this capability now, so maybe in a future version.</span>

<span class="sd">This module contains a few pre-defined analytic spectra which you can use as examples. See the :mod:`AnalyticSpectraObjects` module.</span>

<span class="sd">This module provides basic analytic spectrum capabilites. There is a simple principle at work in this module: Do all calculations as late as possible. As such, most spectra will be defined as basic analytic spectra. However, the use of the :class:`CompositeSpectra` class allows spectra to be used in mathematics::</span>
<span class="sd">    </span>
<span class="sd">    A = AnalyticSpectrum()</span>
<span class="sd">    B = AnaltyicSpectrum()</span>
<span class="sd">    C = A + B * 20</span>
<span class="sd">   </span>
<span class="sd">.. Note::</span>
<span class="sd">    I believe that STSCI Python has some spectrum capabilities, and I am researching combining this module to provide adaptors for the STSCI implementation.</span>

<span class="sd">Module Structure</span>
<span class="sd">----------------</span>

<span class="sd">This module is built on a foundation of Analytic and semi-Analytic spectra. Analytic spectra are spectra that can be described purely as functions. They are known quantities, and show none of the features of a discritized, measured spectrum. The :class:`AnalyticSpectrum` class provides an abstract base for this type of spectra. The :class:`CompositeSpectra` manages the mathematical operations that can be performed on any :class:`AnalyticSpectrum`.</span>

<span class="sd">The :class:`.AstroObjectBase.AnalyticMixin` is a mixin which provides for using data **frames** as analytic objects with no data access attributes.</span>

<span class="sd">The :class:`InterpolatedSpectrum` provides a spectrum which is entered as raw data (like a :class:`.AstroSpectra.SpectraFrame`) and then returned, using a transformation function, as a different, discrite spectrum. The methods for this transformation are defined in :class:`InterpolatedSpectrumBase`. The :class:`SpectraMixin` provides the properties and plotting methods used by spectra which have discrete raw data.</span>

<span class="sd">:class:`UnitarySpectrum` is used to perform a single interpolation operation on a spectrum, *when that spectrum is called*. As it operates when the spectrum is called, it does not contain accessible *raw data*, and so is &quot;analytic&quot; in some sense.</span>

<span class="sd">:class:`Resolver` is used to perform a single interpolation on a spectrum *immediately*. As such, it is a full-class spectrum like an :class:`InterpolatedSpectrum`.</span>

<span class="sd">The :class:`FlatSpectrum`, :class:`GaussianSpectrum`, and :class:`BlackBodySpectrum` objects are all analytic spectra with a specific functional implementation (as thier names imply).</span>

<span class="sd">.. inheritance-diagram:: </span>
<span class="sd">    AstroObject.AnalyticSpectra.AnalyticSpectrum</span>
<span class="sd">    AstroObject.AnalyticSpectra.CompositeSpectra</span>
<span class="sd">    AstroObject.AnalyticSpectra.InterpolatedSpectrum</span>
<span class="sd">    AstroObject.AnalyticSpectra.Resolver</span>
<span class="sd">    AstroObject.AnalyticSpectra.UnitarySpectrum	</span>
<span class="sd">    AstroObject.AnalyticSpectra.FlatSpectrum</span>
<span class="sd">	AstroObject.AnalyticSpectra.GaussianSpectrum</span>
<span class="sd">	AstroObject.AnalyticSpectra.BlackBodySpectrum</span>
<span class="sd">    :parts: 1</span>


<span class="sd">Simple Objects</span>
<span class="sd">--------------</span>

<span class="sd">.. autoclass::</span>
<span class="sd">    AstroObject.AnalyticSpectra.AnalyticSpectrum</span>
<span class="sd">    :members:</span>

<span class="sd">.. autoclass::</span>
<span class="sd">    AstroObject.AnalyticSpectra.CompositeSpectra</span>
<span class="sd">    :members:</span>
<span class="sd">    :inherited-members:</span>
<span class="sd">    </span>
<span class="sd">    .. automethod:: __call__</span>

<span class="sd">Expansion Objects</span>
<span class="sd">-----------------</span>

<span class="sd">These objects expand the concept of an analytic spectrum to be any spectrum which can respond to calls with arbitrary wavelength boundaries. The spectra in the :class:`InterpolatedSpectrum` class rely on a number of potential methods to calculate the desired wavelength values. The public methods for this class are generally the accepted potential resolution methods.</span>

<span class="sd">.. autoclass::</span>
<span class="sd">    AstroObject.AnalyticSpectra.InterpolatedSpectrum</span>
<span class="sd">    :members:</span>
<span class="sd">    :inherited-members:</span>
<span class="sd">    </span>
<span class="sd">    .. automethod:: __call__</span>
<span class="sd">    </span>
<span class="sd">    .. automethod:: _presanity</span>
<span class="sd">    </span>
<span class="sd">    .. automethod:: _postsanity</span>

<span class="sd">.. autoclass::</span>
<span class="sd">    AstroObject.AnalyticSpectra.Resolver</span>
<span class="sd">        </span>
<span class="sd">    .. automethod:: __call__</span>

<span class="sd">    </span>
<span class="sd">.. autoclass::</span>
<span class="sd">    AstroObject.AnalyticSpectra.UnitarySpectrum</span>
<span class="sd">        </span>
<span class="sd">    .. automethod:: __call__</span>
<span class="sd">    </span>

<span class="sd">Analytic Spectrum Objects</span>
<span class="sd">-------------------------</span>

<span class="sd">These objects actually have spectral functions included.</span>

<span class="sd">.. autoclass::</span>
<span class="sd">    AstroObject.AnalyticSpectra.BlackBodySpectrum</span>
<span class="sd">    :members:</span>
<span class="sd">    :inherited-members:</span>
<span class="sd">    </span>
<span class="sd">    .. automethod:: __call__</span>
<span class="sd">    </span>

<span class="sd">.. autoclass::</span>
<span class="sd">    AstroObject.AnalyticSpectra.GaussianSpectrum</span>
<span class="sd">    :members:</span>
<span class="sd">    :inherited-members:</span>
<span class="sd">    </span>
<span class="sd">    .. automethod:: __call__</span>
<span class="sd">    </span>

<span class="sd">.. autoclass::</span>
<span class="sd">    AstroObject.AnalyticSpectra.FlatSpectrum</span>
<span class="sd">    :members:</span>
<span class="sd">    :inherited-members:</span>
<span class="sd">    </span>
<span class="sd">    .. automethod:: __call__</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="c"># Parent Modules</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">AstroObjectBase</span><span class="p">,</span><span class="n">AstroImage</span><span class="p">,</span><span class="n">AstroSpectra</span>

<span class="c"># Standard Scipy Toolkits</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pyfits</span> <span class="kn">as</span> <span class="nn">pf</span>
<span class="kn">import</span> <span class="nn">scipy</span> <span class="kn">as</span> <span class="nn">sp</span>

<span class="c"># Scipy Extras</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">ndimage</span>
<span class="kn">from</span> <span class="nn">scipy.spatial.distance</span> <span class="kn">import</span> <span class="n">cdist</span>
<span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">norm</span>
<span class="kn">import</span> <span class="nn">scipy.interpolate</span>
<span class="kn">import</span> <span class="nn">scipy.integrate</span>

<span class="c"># Standard Python Modules</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">itertools</span>

<span class="c"># Submodules from this system</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">AstroObjectLogging</span> <span class="k">as</span> <span class="n">logging</span>
<span class="kn">from</span> <span class="nn">.util</span> <span class="kn">import</span> <span class="n">getVersion</span><span class="p">,</span> <span class="n">npArrayInfo</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s">&quot;AnalyticSpectrum&quot;</span><span class="p">,</span><span class="s">&quot;CompositeSpectra&quot;</span><span class="p">,</span><span class="s">&quot;InterpolatedSpectrum&quot;</span><span class="p">,</span><span class="s">&quot;InterpolatedSpectrumBase&quot;</span><span class="p">,</span><span class="s">&quot;Resolver&quot;</span><span class="p">,</span><span class="s">&quot;UnitarySpectrum&quot;</span><span class="p">]</span>

<span class="n">LOG</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>

<div class="viewcode-block" id="AnalyticSpectrum"><a class="viewcode-back" href="../../AnalyticSpectra.html#AstroObject.AnalyticSpectra.AnalyticSpectrum">[docs]</a><span class="k">class</span> <span class="nc">AnalyticSpectrum</span><span class="p">(</span><span class="n">AstroObjectBase</span><span class="o">.</span><span class="n">BaseFrame</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;A functional spectrum object for spectrum generation. This is an abstract class which implements spectrum arithmetic. Spectrum arithmetic has a delayed implementation, whereby it is applied to the spectrum only once the spectrum is called for data, allowing spectra to produce data which matches the requested wavelengths (and resolution, if applicable).</span>
<span class="sd">    </span>
<span class="sd">    The Analytic spectrum can be provided with a set of wavelengths upon intialization. The `wavelengths` keyword will be stored and used when this spectrum is later called by the system. The `units` keyword is currently unused.</span>
<span class="sd">    </span>
<span class="sd">    .. inheritance-diagram::</span>
<span class="sd">        AstroObject.AnalyticSpectra.AnalyticSpectrum</span>
<span class="sd">        :parts: 1</span>
<span class="sd">        </span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">data</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">label</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">wavelengths</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">units</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">AnalyticSpectrum</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span><span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_wavelengths</span> <span class="o">=</span> <span class="n">wavelengths</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">units</span> <span class="o">=</span> <span class="n">units</span> <span class="c">#Future will be used for enforcing unit behaviors</span>
        
    <span class="k">def</span> <span class="nf">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Implements spectrum addition&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CompositeSpectra</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">,</span><span class="s">&#39;add&#39;</span><span class="p">)</span>
        
    
    <span class="k">def</span> <span class="nf">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Implements spectrum multiplication&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CompositeSpectra</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">,</span><span class="s">&#39;mul&#39;</span><span class="p">)</span>
        
    
    <span class="k">def</span> <span class="nf">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Implements spectrum subtraction&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CompositeSpectra</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">,</span><span class="s">&#39;sub&#39;</span><span class="p">)</span>
        
    <span class="k">def</span> <span class="nf">__div__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Implements spectrum division&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CompositeSpectra</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">,</span><span class="s">&#39;div&#39;</span><span class="p">)</span>
    
    
    <span class="k">def</span> <span class="nf">__rsub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Reverse subtraction&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CompositeSpectra</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="bp">self</span><span class="p">,</span><span class="s">&#39;sub&#39;</span><span class="p">)</span>
        
    <span class="k">def</span> <span class="nf">__rdiv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Reverse division&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CompositeSpectra</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="bp">self</span><span class="p">,</span><span class="s">&#39;div&#39;</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Reverse Multiplication&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CompositeSpectra</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="bp">self</span><span class="p">,</span><span class="s">&#39;mul&#39;</span><span class="p">)</span>
        
    
    <span class="k">def</span> <span class="nf">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Reverse Addition&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">CompositeSpectra</span><span class="p">(</span><span class="n">other</span><span class="p">,</span><span class="bp">self</span><span class="p">,</span><span class="s">&#39;add&#39;</span><span class="p">)</span>
        
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">requested_wavelengths</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wavelengths</span>
    

</div>
<div class="viewcode-block" id="CompositeSpectra"><a class="viewcode-back" href="../../AnalyticSpectra.html#AstroObject.AnalyticSpectra.CompositeSpectra">[docs]</a><span class="k">class</span> <span class="nc">CompositeSpectra</span><span class="p">(</span><span class="n">AstroObjectBase</span><span class="o">.</span><span class="n">AnalyticMixin</span><span class="p">,</span><span class="n">AnalyticSpectrum</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Binary composition of two functional spectra. This object should not be initialized by the user. Instead, this class is returned when you combine two spectra of different types, or combine a spectra with any other type. As such, do not initialze composite spectra idependently. See the :meth:`__call__` function for documentation of how to use this type of object.</span>
<span class="sd">    </span>
<span class="sd">    .. inheritance-diagram::</span>
<span class="sd">        AstroObject.AnalyticSpectra.CompositeSpectra</span>
<span class="sd">        :parts: 1</span>
<span class="sd">        </span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ops</span> <span class="o">=</span> <span class="p">{</span><span class="s">&#39;sub&#39;</span><span class="p">:</span><span class="s">u&quot;-&quot;</span><span class="p">,</span><span class="s">&#39;add&#39;</span><span class="p">:</span><span class="s">u&quot;+&quot;</span><span class="p">,</span><span class="s">&#39;mul&#39;</span><span class="p">:</span><span class="s">u&quot;*&quot;</span><span class="p">,</span><span class="s">&#39;div&#39;</span><span class="p">:</span><span class="s">u&quot;/&quot;</span><span class="p">}</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">partA</span><span class="p">,</span> <span class="n">partB</span><span class="p">,</span> <span class="n">operation</span><span class="p">):</span>
        <span class="n">label</span> <span class="o">=</span> <span class="s">u&quot;(&quot;</span>
        <span class="n">label</span> <span class="o">+=</span> <span class="n">partA</span><span class="o">.</span><span class="n">label</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">partA</span><span class="p">,</span><span class="s">&#39;label&#39;</span><span class="p">)</span> <span class="k">else</span> <span class="nb">unicode</span><span class="p">(</span><span class="n">partA</span><span class="p">)</span>
        <span class="n">label</span> <span class="o">+=</span> <span class="s">u&quot;) &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">ops</span><span class="p">[</span><span class="n">operation</span><span class="p">]</span> <span class="o">+</span> <span class="s">u&quot; (&quot;</span>
        <span class="n">label</span> <span class="o">+=</span> <span class="n">partB</span><span class="o">.</span><span class="n">label</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">partB</span><span class="p">,</span><span class="s">&#39;label&#39;</span><span class="p">)</span> <span class="k">else</span> <span class="nb">unicode</span><span class="p">(</span><span class="n">partB</span><span class="p">)</span>
        <span class="n">label</span> <span class="o">+=</span> <span class="s">u&quot;)&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">operation</span> <span class="o">=</span> <span class="n">operation</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">CompositeSpectra</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span><span class="n">label</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">A</span> <span class="o">=</span> <span class="n">partA</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">B</span> <span class="o">=</span> <span class="n">partB</span>
        
    <span class="k">def</span> <span class="nf">__valid__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check that the operation here is included in the system.&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">operation</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ops</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">CompositeSpectra</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__valid__</span><span class="p">()</span>
        
    
    
<div class="viewcode-block" id="CompositeSpectra.__call__"><a class="viewcode-back" href="../../AnalyticSpectra.html#AstroObject.AnalyticSpectra.CompositeSpectra.__call__">[docs]</a>    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">wavelengths</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calls the composite function components. The keyword arguments are passed on to calls to spectra contained within this composite spectra. All spectra varieties should accept arbitrary keywords, so this argument is used to pass keywords to spectra which require specific alternatives. Pass in `wavelengths` to use the given wavelengths. If none are passed in, it will look for object-level saved wavelengths, which you can specify simply by setting the `self._wavelengths` parameter on the object.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">wavelengths</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">wavelengths</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wavelengths</span>
        <span class="k">if</span> <span class="n">wavelengths</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">u&quot;No wavelengths specified in </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">))</span>
            
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">,</span><span class="n">AnalyticSpectrum</span><span class="p">):</span>
            <span class="n">Awavelengths</span><span class="p">,</span><span class="n">Avalue</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span><span class="p">(</span><span class="n">wavelengths</span><span class="o">=</span><span class="n">wavelengths</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Avalue</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">A</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">B</span><span class="p">,</span><span class="n">AnalyticSpectrum</span><span class="p">):</span>
            <span class="n">Bwavelengths</span><span class="p">,</span><span class="n">Bvalue</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">B</span><span class="p">(</span><span class="n">wavelengths</span><span class="o">=</span><span class="n">wavelengths</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Bvalue</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">B</span>
        
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">operation</span> <span class="o">==</span> <span class="s">&#39;add&#39;</span><span class="p">:</span>
            <span class="n">Result</span> <span class="o">=</span> <span class="n">Avalue</span> <span class="o">+</span> <span class="n">Bvalue</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">operation</span> <span class="o">==</span> <span class="s">&#39;mul&#39;</span><span class="p">:</span>
            <span class="n">Result</span> <span class="o">=</span> <span class="n">Avalue</span> <span class="o">*</span> <span class="n">Bvalue</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">operation</span> <span class="o">==</span> <span class="s">&#39;sub&#39;</span><span class="p">:</span>
            <span class="n">Result</span> <span class="o">=</span> <span class="n">Avalue</span> <span class="o">-</span> <span class="n">Bvalue</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">operation</span> <span class="o">==</span> <span class="s">&#39;div&#39;</span><span class="p">:</span>
            <span class="n">Result</span> <span class="o">=</span> <span class="n">Avalue</span> <span class="o">/</span> <span class="n">Bvalue</span>
        <span class="k">if</span> <span class="n">Result</span> <span class="o">!=</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">wavelengths</span><span class="p">,</span><span class="n">Result</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">u&quot;Composition did not produce a value result!&quot;</span><span class="p">)</span>
        
    

</div></div>
<span class="k">class</span> <span class="nc">InterpolatedSpectrumBase</span><span class="p">(</span><span class="n">AnalyticSpectrum</span><span class="p">,</span><span class="n">AstroObjectBase</span><span class="o">.</span><span class="n">BaseFrame</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">wavelengths</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">resolution</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s">u&quot;interpolate&quot;</span><span class="p">,</span><span class="n">integrator</span><span class="o">=</span><span class="s">&#39;integrate_hist&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">method</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">default_integrator</span> <span class="o">=</span> <span class="n">integrator</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">InterpolatedSpectrumBase</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span><span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_wavelengths</span> <span class="o">=</span> <span class="n">wavelengths</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">resolution</span> <span class="o">=</span> <span class="n">resolution</span>        
    
    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">method</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calls this interpolated spectrum over certain wavelengths. The `method` parameter will default to the one set for the object, and controls the method used to interpret this spectrum. Available methods include all members of :class:`InterpolatedSpectrum` which provide return values (all those documented below).&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">method</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">method</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">method</span><span class="p">,</span><span class="nb">str</span><span class="p">):</span>
            <span class="n">method</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">method</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">method</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        
    <span class="k">def</span> <span class="nf">_presanity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">oldwl</span><span class="p">,</span><span class="n">oldfl</span><span class="p">,</span><span class="n">newwl</span><span class="p">,</span><span class="n">newrs</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">extrapolate</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">upsample</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">debug</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">warning</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">error</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">message</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sanity checks performed before any specturm operation. `oldwl` and `oldfl` are the given wavelengths and flux for the spectrum. `newwl` and `newrs` are the requested wavelengths and resolution (respectively) for the spectrum. `extrapolate` allows the new wavelengths to extraopolate from the old ones. If not, only operations that appear to interpolate will be allowed. `upsample` allows the operation to get more resolution information than is already present in the spectrum. `warning` and `debug` flip those flags prematurely, to force warning or debug output. `error` should be an error class to be raised by the sanity checks. These keywords allow custom sanity checks to be performed before calling this function. The benefit of this system, is that sanity checks are all run on every operation, allowing the user to examine all of the potenital problems simultaneously, rather than one at a time, as each successive check is run. The arbitrary keywords at the end allow the user to feed a dictionary of array names and arrays to be included in the sanity check output in the case of failure.</span>
<span class="sd">        </span>
<span class="sd">        Checks include:</span>
<span class="sd">        </span>
<span class="sd">        - Wavelength Units (between 1e-12 and 1e-3)</span>
<span class="sd">        </span>
<span class="sd">        - Wavelengths must be montonically increasing</span>
<span class="sd">        </span>
<span class="sd">        - Given flux should be greater than 0 (Warning)</span>
<span class="sd">        </span>
<span class="sd">        - Requested Wavelength and Resolution should shape match.</span>
<span class="sd">        </span>
<span class="sd">        - Given flux and wavelength should shape match.</span>
<span class="sd">        </span>
<span class="sd">        - Requested resolution should be positive</span>
<span class="sd">        </span>
<span class="sd">        - If `extrapolate` then the reuqested wavelengths should be within some tolerance of the given wavelengths. If `extrapolate` is false, then the given wavelengths should fit within the bounds of the given wavelengths.</span>
<span class="sd">        </span>
<span class="sd">        - If `newrs` (Requested resolution) is given, it must not reuqest more information than is already present in the data. The `upsample` keyword disables this effect.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c"># Unit sanity check</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">message</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">+=</span> <span class="p">[</span><span class="n">message</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">error</span> <span class="ow">or</span> <span class="n">warning</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">+=</span> <span class="p">[</span><span class="s">u&quot;Unkown alert triggered.&quot;</span><span class="p">]</span>
            <span class="n">debug</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="n">dmsg</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">arrays</span> <span class="o">=</span> <span class="n">kwargs</span>
        <span class="n">newrb</span> <span class="o">=</span> <span class="bp">True</span> <span class="k">if</span> <span class="n">newrs</span> <span class="o">!=</span> <span class="bp">None</span> <span class="k">else</span> <span class="bp">False</span>
        
        <span class="c"># Check that the units of this spectrum look like SI units, inbound and outbound.</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">oldwl</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-12</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">oldwl</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">1e-3</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">+=</span> <span class="p">[</span><span class="s">u&quot;</span><span class="si">%s</span><span class="s">: Given λ units appear wrong!&quot;</span><span class="p">]</span>
            <span class="n">arrays</span><span class="p">[</span><span class="s">u&quot;Given λ&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">oldwl</span>
        
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">newwl</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-12</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">newwl</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">1e-3</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">+=</span> <span class="p">[</span><span class="s">u&quot;</span><span class="si">%s</span><span class="s">: Requested λ units appear wrong!&quot;</span><span class="p">]</span>
            <span class="n">arrays</span><span class="p">[</span><span class="s">u&quot;Requested λ&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">newwl</span>
        
        <span class="c"># Check that the units of the spectrum are monotonically increasing (inbound and outbound)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">oldwl</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="n">msg</span> <span class="o">+=</span> <span class="p">[</span><span class="s">u&quot;Given λ must be monotonically increasing.&quot;</span><span class="p">]</span>
            <span class="n">arrays</span><span class="p">[</span><span class="s">u&quot;Given λ&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">oldwl</span>
            <span class="n">error</span> <span class="o">=</span> <span class="ne">ValueError</span>
        <span class="k">try</span><span class="p">:</span>    
            <span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">newwl</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="n">msg</span> <span class="o">+=</span> <span class="p">[</span><span class="s">u&quot;Requested λ must be monotonically increasing.&quot;</span><span class="p">]</span>
                <span class="n">arrays</span><span class="p">[</span><span class="s">u&quot;Requested λ&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">newwl</span>
                <span class="n">error</span> <span class="o">=</span> <span class="ne">ValueError</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">+=</span> <span class="p">[</span><span class="s">u&quot;Requested λ threw an error&quot;</span><span class="p">]</span>
            <span class="n">arrays</span><span class="p">[</span><span class="s">u&quot;Requested λ&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">newwl</span>
            <span class="n">error</span> <span class="o">=</span> <span class="ne">ValueError</span>
            
        
        <span class="c"># Check that we have non-zero, positive flux provided.</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">oldfl</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="n">msg</span> <span class="o">+=</span> <span class="p">[</span><span class="s">u&quot;Given flux &lt;= 0 at some point.&quot;</span><span class="p">]</span>
            <span class="n">arrays</span><span class="p">[</span><span class="s">u&quot;Given Flux&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">oldfl</span>
        
        <span class="c"># Data shape sanity check</span>
        <span class="k">if</span> <span class="n">newrb</span> <span class="ow">and</span> <span class="n">newrs</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">newwl</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="n">dmsg</span> <span class="o">+=</span> <span class="p">[</span><span class="s">u&quot;</span><span class="si">%s</span><span class="s">: λ shape: </span><span class="si">%s</span><span class="s">, R shape: </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">newwl</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">newrs</span><span class="o">.</span><span class="n">shape</span><span class="p">)]</span>
            <span class="n">msg</span> <span class="o">+=</span> <span class="p">[</span><span class="s">u&quot;Shape Mismatch between R and λ&quot;</span><span class="p">]</span>
            <span class="n">error</span> <span class="o">=</span> <span class="ne">AttributeError</span>
            
        <span class="k">if</span> <span class="n">oldwl</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">oldfl</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="n">dmsg</span> <span class="o">+=</span> <span class="p">[</span><span class="s">u&quot;</span><span class="si">%s</span><span class="s">: λ shape: </span><span class="si">%s</span><span class="s">, flux shape: </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">oldwl</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">oldrs</span><span class="o">.</span><span class="n">shape</span><span class="p">)]</span>
            <span class="n">msg</span> <span class="o">+=</span> <span class="p">[</span><span class="s">u&quot;Shape Mismatch between flux and λ&quot;</span><span class="p">]</span>
            <span class="n">error</span> <span class="o">=</span> <span class="ne">AttributeError</span>
        
        <span class="c"># Check that resolution is nonzero positive.</span>
        <span class="k">if</span> <span class="n">newrb</span> <span class="ow">and</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">newrs</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="n">msg</span> <span class="o">+=</span> <span class="p">[</span><span class="s">u&quot;Requested R is less than zero!&quot;</span><span class="p">]</span>
            <span class="n">arrays</span><span class="p">[</span><span class="s">u&quot;Requested R&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">newrs</span>
            <span class="n">error</span> <span class="o">=</span> <span class="ne">AttributeError</span>
            
        
        <span class="c"># Interpolation tolerance check</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">extrapolate</span><span class="p">:</span>
            <span class="n">mintol</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">oldwl</span><span class="p">)</span>
            <span class="n">maxtol</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">oldwl</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">newrs</span> <span class="o">!=</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c"># Tolerance for interpolation is set here:</span>
            <span class="n">tolfrac</span> <span class="o">=</span> <span class="mi">2</span> <span class="c"># Maximum interpolation is 1/8th of a resolution element.</span>
            <span class="n">mintol</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">oldwl</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">oldwl</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">oldwl</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">tolfrac</span>
            <span class="n">maxtol</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">oldwl</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">oldwl</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">oldwl</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="n">tolfrac</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tolfrac</span> <span class="o">=</span> <span class="mf">1.001</span>
            <span class="n">mintol</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">oldwl</span><span class="p">)</span> <span class="o">/</span> <span class="n">tolfrac</span>
            <span class="n">maxtol</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">oldwl</span><span class="p">)</span> <span class="o">*</span> <span class="n">tolfrac</span>
        

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">newwl</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">mintol</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">newwl</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">maxtol</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">extrapolate</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">+=</span> <span class="p">[</span><span class="s">u&quot;Should not extrapolate during reampling process. Please provide new λ that are within the range of old ones.&quot;</span><span class="p">]</span>
                <span class="n">warning</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">+=</span> <span class="p">[</span><span class="s">u&quot;Can not extrapolate during reampling process. Please provide new λ that are within the range of old ones.&quot;</span><span class="p">]</span>
                <span class="n">error</span> <span class="o">=</span> <span class="ne">ValueError</span>
            <span class="n">arrays</span><span class="p">[</span><span class="s">u&quot;Requested λ&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">newwl</span>
            <span class="n">arrays</span><span class="p">[</span><span class="s">u&quot;Given λ&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">oldwl</span>
            <span class="n">dmsg</span> <span class="o">+=</span> <span class="p">[</span><span class="s">u&quot;</span><span class="si">%s</span><span class="s">: Allowed range for Requested λ: [</span><span class="si">%g</span><span class="s">,</span><span class="si">%g</span><span class="s">]&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">mintol</span><span class="p">,</span><span class="n">maxtol</span><span class="p">)]</span>
        
        <span class="n">oldrs</span> <span class="o">=</span>  <span class="n">oldwl</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">oldwl</span><span class="p">)</span>
        
        <span class="c"># Resolution Sanity Check</span>
        <span class="c"># The system cannot generate more information than was already there. As such, the new resolution should be worse than the original.</span>
        <span class="k">if</span> <span class="n">newrb</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">newrs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">oldrs</span><span class="p">):</span>
                <span class="n">oldrsf</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span><span class="n">oldwl</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">oldrs</span><span class="p">,</span><span class="n">bounds_error</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">fill_value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">oldrs</span><span class="p">))</span>
                <span class="n">oldrsd</span> <span class="o">=</span> <span class="n">oldrsf</span><span class="p">(</span><span class="n">newwl</span><span class="p">)</span>
                <span class="n">delrs</span> <span class="o">=</span> <span class="n">newrs</span> <span class="o">-</span> <span class="n">oldrsd</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">delrs</span> <span class="o">&gt;</span> <span class="mf">1.0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                    <span class="n">rswi</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">delrs</span><span class="p">)</span>
                    <span class="n">msg</span> <span class="o">+=</span> <span class="p">[</span><span class="s">u&quot;Requested R is more detailed than given R. </span><span class="si">%g</span><span class="s"> -&gt; </span><span class="si">%g</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">newrs</span><span class="p">[</span><span class="n">rswi</span><span class="p">],</span><span class="n">oldrsd</span><span class="p">[</span><span class="n">rswi</span><span class="p">])]</span>
                    <span class="n">arrays</span><span class="p">[</span><span class="s">u&quot;Requested R&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">newrs</span>
                    <span class="n">arrays</span><span class="p">[</span><span class="s">u&quot;Given R&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">oldrs</span>
                    <span class="n">arrays</span><span class="p">[</span><span class="s">u&quot;Given interpolated R&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">oldrsd</span>
                    <span class="n">arrays</span><span class="p">[</span><span class="s">u&quot;Given Δλ&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">oldwl</span><span class="p">)</span>
                    <span class="n">arrays</span><span class="p">[</span><span class="s">u&quot;Given λ&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">oldwl</span>
                    <span class="n">arrays</span><span class="p">[</span><span class="s">u&quot;Difference in R&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">delrs</span>
                    <span class="k">if</span> <span class="n">upsample</span><span class="p">:</span>
                        <span class="n">warning</span> <span class="o">=</span> <span class="bp">True</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">error</span> <span class="o">=</span> <span class="ne">ValueError</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">msg</span> <span class="o">+=</span> <span class="p">[</span><span class="s">u&quot;Requested R may be close to same detail as given R. Fidelity might not be preserved.&quot;</span><span class="p">]</span>
                    <span class="n">arrays</span><span class="p">[</span><span class="s">u&quot;Requested R&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">newrs</span>
                    <span class="n">arrays</span><span class="p">[</span><span class="s">u&quot;Given R&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">oldrs</span>
                                        
        <span class="k">if</span> <span class="n">debug</span><span class="p">:</span>
            <span class="n">arrays</span><span class="p">[</span><span class="s">u&quot;Requested λ&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">newwl</span>
            <span class="n">arrays</span><span class="p">[</span><span class="s">u&quot;Given λ&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">oldwl</span>
            <span class="n">arrays</span><span class="p">[</span><span class="s">u&quot;Given Flux&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">oldfl</span>
            <span class="k">if</span> <span class="n">newrb</span><span class="p">:</span>
                <span class="n">arrays</span><span class="p">[</span><span class="s">u&quot;Requested R&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">newrs</span>
        
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="n">error</span> <span class="ow">or</span> <span class="n">warning</span><span class="p">):</span>
            <span class="n">debug</span> <span class="o">=</span> <span class="bp">True</span>
                      
        <span class="k">if</span> <span class="n">error</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">msg</span><span class="p">:</span>
                <span class="n">LOG</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">warning</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">msg</span><span class="p">:</span>
                <span class="n">LOG</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">debug</span><span class="p">:</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">u&quot;Pre Sanity-Check Debugging Information:&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">msg</span><span class="p">:</span>
                <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
            
        <span class="k">if</span> <span class="n">error</span> <span class="ow">or</span> <span class="n">warning</span> <span class="ow">or</span> <span class="n">debug</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">dm</span> <span class="ow">in</span> <span class="n">dmsg</span><span class="p">:</span>
                <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">dm</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span><span class="n">array</span> <span class="ow">in</span> <span class="n">arrays</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
                <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">u&quot;</span><span class="si">%s</span><span class="s">: </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">npArrayInfo</span><span class="p">(</span><span class="n">array</span><span class="p">,</span><span class="n">name</span><span class="p">)))</span>
                
        <span class="k">if</span> <span class="n">error</span><span class="p">:</span>
            <span class="n">e</span> <span class="o">=</span> <span class="n">error</span><span class="p">(</span><span class="n">msg</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">raise</span> <span class="n">e</span>
        
            
    <span class="k">def</span> <span class="nf">_postsanity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">oldwl</span><span class="p">,</span><span class="n">oldfl</span><span class="p">,</span><span class="n">newwl</span><span class="p">,</span><span class="n">newfl</span><span class="p">,</span><span class="n">newrs</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">extrapolate</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">debug</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">warning</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">error</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">message</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sanity checks performed before any specturm operation. `oldwl` and `oldfl` are the given wavelengths and flux for the spectrum. `newwl` and `newfl` are the found wavelengths and flux (respectively) for the spectrum. `newrs` is the requested resolution. `extrapolate` allows the new wavelengths to extraopolate from the old ones. If not, only operations that appear to interpolate will be allowed. `upsample` allows the operation to get more resolution information than is already present in the spectrum. `warning` and `debug` flip those flags prematurely, to force warning or debug output. `error` should be an error class to be raised by the sanity checks. These keywords allow custom sanity checks to be performed before calling this function. The benefit of this system, is that sanity checks are all run on every operation, allowing the user to examine all of the potenital problems simultaneously, rather than one at a time, as each successive check is run. The arbitrary keywords at the end allow the user to feed a dictionary of array names and arrays to be included in the sanity check output in the case of failure.</span>
<span class="sd">        </span>
<span class="sd">        Checks performed are:</span>
<span class="sd">        </span>
<span class="sd">        - ``NaN`` not allowed in found flux.</span>
<span class="sd">        </span>
<span class="sd">        - ``0`` not allowed in more than ``1%%`` of fluxes. (**Warning**)</span>
<span class="sd">        </span>
<span class="sd">        - If there were no ``0`` s in the old flux, then the new flux should have no ``0`` s (**Warning**)</span>
<span class="sd">        </span>
<span class="sd">        - Flux and wavelength should have the same shape.</span>
<span class="sd">        </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">dmsg</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">message</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">+=</span> <span class="p">[</span><span class="n">message</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">error</span> <span class="ow">or</span> <span class="n">warning</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">+=</span> <span class="p">[</span><span class="s">u&quot;Unkown alert triggered.&quot;</span><span class="p">]</span>
            <span class="n">debug</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="n">arrays</span> <span class="o">=</span> <span class="n">kwargs</span>
        <span class="n">arrays</span><span class="p">[</span><span class="s">u&quot;Requested λ&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">newwl</span>
        <span class="n">arrays</span><span class="p">[</span><span class="s">u&quot;Given λ&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">oldwl</span>
        <span class="n">arrays</span><span class="p">[</span><span class="s">u&quot;New Flux&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">newfl</span>
        <span class="n">arrays</span><span class="p">[</span><span class="s">u&quot;Given Flux&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">oldfl</span>
        <span class="n">newrb</span> <span class="o">=</span> <span class="bp">True</span> <span class="k">if</span> <span class="n">newrs</span> <span class="o">!=</span> <span class="bp">None</span> <span class="k">else</span> <span class="bp">False</span>
        <span class="k">if</span> <span class="n">newrb</span><span class="p">:</span>
            <span class="n">arrays</span><span class="p">[</span><span class="s">u&quot;Requested R&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">newrs</span>
                
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">newfl</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="n">msg</span> <span class="o">+=</span> <span class="p">[</span><span class="s">u&quot;Detected NaN in Flux!&quot;</span><span class="p">]</span>
            <span class="n">error</span> <span class="o">=</span> <span class="ne">ValueError</span>
                
        <span class="k">if</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">newfl</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">))</span><span class="o">/</span><span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">newfl</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mf">0.01</span> <span class="ow">and</span> <span class="p">(</span><span class="n">oldfl</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">extrapolate</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">+=</span> <span class="p">[</span><span class="s">u&quot;New Flux &lt;= 0 for more than 1</span><span class="si">% o</span><span class="s">f points&quot;</span><span class="p">]</span>
            <span class="n">warning</span> <span class="o">=</span> <span class="bp">True</span>
            
        <span class="k">if</span> <span class="n">newfl</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">newwl</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">+=</span> <span class="p">[</span><span class="s">u&quot;λ lengths have changed: </span><span class="si">%s</span><span class="s"> -&gt; </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">newfl</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">newwl</span><span class="o">.</span><span class="n">shape</span><span class="p">)]</span>
            <span class="n">error</span> <span class="o">=</span> <span class="ne">ValueError</span>
        
        <span class="k">if</span> <span class="p">(</span><span class="n">newfl</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">()</span> <span class="ow">and</span> <span class="p">(</span><span class="n">oldfl</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">():</span>
            <span class="n">msg</span> <span class="o">+=</span> <span class="p">[</span><span class="s">u&quot;New Flux &lt;= 0 some point!&quot;</span><span class="p">]</span>
            <span class="n">warning</span> <span class="o">=</span> <span class="bp">True</span>
        
        <span class="k">if</span> <span class="n">error</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">msg</span><span class="p">:</span>
                <span class="n">LOG</span><span class="o">.</span><span class="n">critical</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">warning</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">msg</span><span class="p">:</span>
                <span class="n">LOG</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">debug</span><span class="p">:</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">u&quot;Pre Sanity-Check Debugging Information:&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">error</span> <span class="ow">or</span> <span class="n">warning</span> <span class="ow">or</span> <span class="n">debug</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">dm</span> <span class="ow">in</span> <span class="n">dmsg</span><span class="p">:</span>
                <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">dm</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span><span class="n">array</span> <span class="ow">in</span> <span class="n">arrays</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
                <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">u&quot;</span><span class="si">%s</span><span class="s">: </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">npArrayInfo</span><span class="p">(</span><span class="n">array</span><span class="p">,</span><span class="n">name</span><span class="p">)))</span>                
        <span class="k">if</span> <span class="n">error</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">error</span><span class="p">(</span><span class="n">msg</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        
        
    <span class="k">def</span> <span class="nf">interpolate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">wavelengths</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">extrapolate</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Uses a 1d Interpolation to fill in missing spectrum values.</span>
<span class="sd">        </span>
<span class="sd">        This interpolator uses the scipy.interpolate.interp1d method to interpolate between data points in the original spectrum. Normally, this method will not allow extrapolation. The keywords `extrapolate` and `fill_value` can be used to trigger extrapolation away from the interpolated values.</span>
<span class="sd">        </span>
<span class="sd">        Input should be a set of wavelengths requested for the system (in the `wavelengths` keyword). These wavelengths should not exceed the bounds of the given wavelengths for this spectrum (doing so doesn&#39;t really make sense for interpolation. See :meth:`polyfit` for a case where this might make sense.). The output will be a data array of wavelengths and fluxes (should be the provided `wavelengths`, and an equivalently shaped array with fluxes.)</span>
<span class="sd">        </span>
<span class="sd">        .. Warning :: This method does not prevent you from interpolating your spectrum into a higher resolution state. As such, it is possible, when calling interpolate, to increase the resolution of the spectrum, and end up &#39;creating&#39; information.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">wavelengths</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">wavelengths</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wavelengths</span>
        <span class="k">if</span> <span class="n">wavelengths</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">u&quot;Requires Wavelenths&quot;</span><span class="p">)</span>
        
        <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">u&quot;Interpolate Starting&quot;</span><span class="p">)</span>
        
        <span class="c"># Sanity Checks for Data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_presanity</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wavelengths</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">flux</span><span class="p">,</span><span class="n">wavelengths</span><span class="p">,</span><span class="n">extrapolate</span><span class="o">=</span><span class="n">extrapolate</span><span class="p">)</span>
        
        <span class="c"># Interpolation function (invented on the spot!)</span>
        <span class="n">func</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wavelengths</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">flux</span><span class="p">,</span><span class="n">bounds_error</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">fill_value</span><span class="o">=</span><span class="n">fill_value</span><span class="p">)</span>
        
        <span class="c"># Actually calling the interpolation</span>
        <span class="n">flux</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">wavelengths</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">_postsanity</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wavelengths</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">flux</span><span class="p">,</span><span class="n">wavelengths</span><span class="p">,</span><span class="n">flux</span><span class="p">)</span>
        <span class="c"># We do print fun information about the final calculation regardless.</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">u&quot;</span><span class="si">%s</span><span class="s">: </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">npArrayInfo</span><span class="p">(</span><span class="n">flux</span><span class="p">,</span><span class="s">&quot;New Flux&quot;</span><span class="p">)))</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">u&quot;Interpolate Finished&quot;</span><span class="p">)</span>
        
        <span class="c"># Finally, return the data in a way that makes sense for the just-in-time spectrum calculation objects</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">wavelengths</span><span class="p">,</span><span class="n">flux</span><span class="p">))</span>
    
    <span class="k">def</span> <span class="nf">polyfit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">wavelengths</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">order</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Uses a 1d fit to find missing spectrum values.</span>
<span class="sd">        </span>
<span class="sd">        This method will extrapolate away from the provided data. The function used is a np.poly1d() using an order 2 np.polyfit. By default, this method will allow extrapolation away from the provided wavelengths. The `order` keyword can be used to adjust the polynomial order for this funciton.</span>
<span class="sd">        </span>
<span class="sd">        Input should be a set of wavelengths requested for the system (in the `wavelengths` keyword). The output will be a data array of wavelengths and fluxes (should be the provided `wavelengths`, and an equivalently shaped array with fluxes.)&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">wavelengths</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">wavelengths</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wavelengths</span>
        <span class="k">if</span> <span class="n">wavelengths</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">u&quot;Requires Wavelenths&quot;</span><span class="p">)</span>
        
        <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">u&quot;Polyfit Starting&quot;</span><span class="p">)</span>
        
        <span class="c"># Sanity Checks for Data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_presanity</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wavelengths</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">flux</span><span class="p">,</span><span class="n">wavelengths</span><span class="p">,</span><span class="n">extrapolate</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        
        <span class="n">func</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">poly1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">polyfit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wavelengths</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">flux</span><span class="p">,</span><span class="n">order</span><span class="p">))</span>
        
        <span class="n">flux</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">wavelengths</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">_postsanity</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wavelengths</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">flux</span><span class="p">,</span><span class="n">wavelengths</span><span class="p">,</span><span class="n">flux</span><span class="p">,</span><span class="n">extrapolate</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="c"># We do print fun information about the final calculation regardless.</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">u&quot;</span><span class="si">%s</span><span class="s">: </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">npArrayInfo</span><span class="p">(</span><span class="n">flux</span><span class="p">,</span><span class="s">&quot;New Flux&quot;</span><span class="p">)))</span>
        
        <span class="c"># Finally, return the data in a way that makes sense for the just-in-time spectrum calculation objects</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">wavelengths</span><span class="p">,</span><span class="n">flux</span><span class="p">))</span>
    
        
    <span class="k">def</span> <span class="nf">resample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">wavelengths</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">resolution</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">upsample</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Resample the given spectrum to a different resolution.</span>
<span class="sd">        </span>
<span class="sd">        Normally, spectra are resolution limited in their sampling. If you want to sample a spectrum at a lower resolution, simply interpolating, or drawing nearest points to your desired wavelength may cause information loss. The resample method convolves the spectrum with a gaussian which has a width appropriate to your desired resolution. This re-distributes the information in the spectrum into neighboring points, preventing the loss of features due to interpolation and sampling errors.</span>
<span class="sd">        </span>
<span class="sd">        The resample spectrum normally does not allow you to up-sample a spectrum to a higher resolution, as this could lead to errors caused by &#39;information creation&#39;, i.e. your spectrum will appear to show more detail than is possible. Hoever, the system will allow upsampling (useful if you are confident that you will later downsample your spectrum) using the `upsample` keyword.</span>
<span class="sd">        </span>
<span class="sd">        Input should be a set of wavelengths requested for the system (in the `wavelengths` keyword) and an array of resolutions requested in the `resolutions` keyword. The output will be a data array of wavelengths and fluxes (should be the provided `wavelengths`, and an equivalently shaped array with fluxes.)</span>
<span class="sd">        </span>
<span class="sd">        .. Note :: If you request more detail than is given in the spectrum, or if you extrapolate on the spectrum, you may encounter parts of the new spectrum that have no data. As the fluxes are normalized, such data segments are set to zero. This will also produce a warning.</span>
<span class="sd">        </span>
<span class="sd">        This is a vector-based calculation, and so should be relatively fast. This function contains ZERO for loops, and uses entirely numpy-based vector mathematics.&quot;&quot;&quot;</span>        
        <span class="k">if</span> <span class="n">wavelengths</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">wavelengths</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wavelengths</span>
        <span class="k">if</span> <span class="n">resolution</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">resolution</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">resolution</span>
        <span class="k">if</span> <span class="n">wavelengths</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">u&quot;Requires Wavelenths&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">resolution</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">u&quot;Requires Resolution&quot;</span><span class="p">)</span>
        
        <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">u&quot;Resample Starting&quot;</span><span class="p">)</span>
        
        
        <span class="c"># Sanity Checks for Data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_presanity</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wavelengths</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">flux</span><span class="p">,</span><span class="n">wavelengths</span><span class="p">,</span><span class="n">resolution</span><span class="p">,</span><span class="n">upsample</span><span class="o">=</span><span class="n">upsample</span><span class="p">)</span>
        
        <span class="c"># The main resampling function.</span>
        <span class="c"># A two dimensional grid is used (instead of two for-loops). The grid stretches across wavelength (data), wavelength (requested). The </span>
        <span class="c"># standard deviation of the blurring gaussian corresponds point-for-point to the requested wavelengths. As such, we will have columns which</span>
        <span class="c"># we can sum to make the new wavelengths, and rows which show the distribution of flux from each old wavelength into each new wavelength.</span>
        <span class="n">sigma</span> <span class="o">=</span> <span class="n">wavelengths</span> <span class="o">/</span> <span class="n">resolution</span> <span class="o">/</span> <span class="mf">2.35</span>
        <span class="n">curve</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">wl</span><span class="p">,</span><span class="n">center</span><span class="p">,</span><span class="n">sig</span> <span class="p">:</span> <span class="p">(</span><span class="mf">1.0</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">sig</span> <span class="o">**</span> <span class="mf">2.0</span> <span class="p">))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span> <span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">wl</span> <span class="o">-</span> <span class="n">center</span><span class="p">)</span> <span class="o">**</span> <span class="mf">2.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">sig</span> <span class="o">**</span> <span class="mf">2.0</span><span class="p">)</span> <span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float</span><span class="p">)</span>
        
        <span class="c"># This is the two dimensional grid for the resampling function.</span>
        <span class="n">MWL</span><span class="p">,</span><span class="n">MCENT</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wavelengths</span><span class="p">,</span><span class="n">wavelengths</span><span class="p">)</span>
        <span class="n">MWL</span><span class="p">,</span><span class="n">MSIGM</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wavelengths</span><span class="p">,</span><span class="n">sigma</span><span class="p">)</span>
        
        <span class="c"># DO THE MATH!</span>
        <span class="n">curves</span> <span class="o">=</span> <span class="n">curve</span><span class="p">(</span><span class="n">MWL</span><span class="p">,</span><span class="n">MCENT</span><span class="p">,</span><span class="n">MSIGM</span><span class="p">)</span>
        
        <span class="c"># We then must normalize the light spread across each aperture by the gaussian. This makes sure the blurring gaussian only distributes</span>
        <span class="c"># the amont of flux under each wavelength.</span>
        <span class="n">ones</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wavelengths</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">base</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">curves</span> <span class="o">*</span> <span class="n">ones</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">top</span>  <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">curves</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">flux</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        
        <span class="c"># If we try to normalize by dividing by zero, we are doing something wrong.</span>
        <span class="c"># Removing these data points should be okay, because they are data points which we calculated to</span>
        <span class="c"># have zero total flux anyways, and so we can ignore them.</span>
        <span class="n">zeros</span> <span class="o">=</span> <span class="n">base</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">topzo</span> <span class="o">=</span> <span class="n">top</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">base</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>    
        <span class="c"># We don&#39;t actually clip those zero data points, we just make them into dumb numbers so that we don&#39;t get divide-by-zero errors</span>
        <span class="n">base</span><span class="p">[</span><span class="n">zeros</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">zeros</span><span class="p">))</span>
        <span class="n">top</span><span class="p">[</span><span class="n">zeros</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">zeros</span><span class="p">))</span>
        
        <span class="c"># Do the actual normalization</span>
        <span class="n">flux</span> <span class="o">=</span> <span class="n">top</span>  <span class="o">/</span> <span class="n">base</span>
        

        <span class="n">msgarray</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s">u&quot;Normalization Denominator&quot;</span> <span class="p">:</span> <span class="n">base</span><span class="p">,</span>
            <span class="s">u&quot;Normalization Numerator&quot;</span> <span class="p">:</span> <span class="n">top</span><span class="p">,</span>
            <span class="s">u&quot;Resolution σ&quot;</span> <span class="p">:</span> <span class="n">sigma</span><span class="p">,</span>
            <span class="s">u&quot;Exponent Value&quot;</span> <span class="p">:</span> <span class="p">(</span><span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">MWL</span> <span class="o">-</span> <span class="n">MCENT</span><span class="p">)</span> <span class="o">**</span> <span class="mf">2.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">MSIGM</span> <span class="o">**</span> <span class="mf">2.0</span><span class="p">)),</span>
            <span class="s">u&quot;Exponent Evaluated&quot;</span> <span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="p">(</span><span class="n">MWL</span> <span class="o">-</span> <span class="n">MCENT</span><span class="p">)</span> <span class="o">**</span> <span class="mf">2.0</span> <span class="o">/</span> <span class="p">(</span><span class="n">MSIGM</span> <span class="o">**</span> <span class="mf">2.0</span><span class="p">)),</span>
            <span class="s">u&quot;Curve Evaluated&quot;</span> <span class="p">:</span> <span class="n">curves</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">topzo</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">zeros</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">))</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_postsanity</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wavelengths</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">flux</span><span class="p">,</span><span class="n">wavelengths</span><span class="p">,</span><span class="n">flux</span><span class="p">,</span><span class="n">resolution</span><span class="p">,</span><span class="n">error</span><span class="o">=</span><span class="ne">ValueError</span><span class="p">,</span><span class="n">message</span><span class="o">=</span><span class="s">u&quot;Normalizing Zero error.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">zeros</span><span class="p">)),</span><span class="o">**</span><span class="n">msgarray</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">zeros</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_postsanity</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wavelengths</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">flux</span><span class="p">,</span><span class="n">wavelengths</span><span class="p">,</span><span class="n">flux</span><span class="p">,</span><span class="n">resolution</span><span class="p">,</span><span class="n">warning</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="n">message</span><span class="o">=</span><span class="s">u&quot;Removed </span><span class="si">%d</span><span class="s"> zeros from re-weighting.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">zeros</span><span class="p">)),</span><span class="o">**</span><span class="n">msgarray</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_postsanity</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wavelengths</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">flux</span><span class="p">,</span><span class="n">wavelengths</span><span class="p">,</span><span class="n">flux</span><span class="p">,</span><span class="n">resolution</span><span class="p">,</span><span class="o">**</span><span class="n">msgarray</span><span class="p">)</span>
            
        
        
        <span class="c"># We do print fun information about the final calculation regardless.</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">u&quot;</span><span class="si">%s</span><span class="s">: </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">npArrayInfo</span><span class="p">(</span><span class="n">flux</span><span class="p">,</span><span class="s">&quot;New Flux&quot;</span><span class="p">)))</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">u&quot;Resample Complete&quot;</span><span class="p">)</span>
                
        <span class="c"># Finally, return the data in a way that makes sense for the just-in-time spectrum calculation objects</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">wavelengths</span><span class="p">,</span><span class="n">flux</span><span class="p">))</span>
    
    
    
    <span class="k">def</span> <span class="nf">integrate_hist</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">wavelengths</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">upscale</span><span class="o">=</span><span class="mi">150</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Performs an integration along wavelengths using the trapezoidal approximation.</span>
<span class="sd">        </span>
<span class="sd">        The integrator uses a trapezoidal approximation, upscaled to include more data points in each trapezoidal section than the requested wavelengths. The integrator then uses the trapezoid approximation from http://en.wikipedia.org/wiki/Trapezoidal_rule to integrate the spectrum. This results in some integration error, but the integration error is presumably small when compared to the speedup gained over :meth:`integrate_quad`.</span>
<span class="sd">        </span>
<span class="sd">        Input should be a set of wavelengths requested for the system (in the `wavelengths` keyword). The output will be a data array of wavelengths and fluxes (should be the provided `wavelengths`, and an equivalently shaped array with fluxes.) The `upscale` keyword controls the degree of oversampling for this method.</span>
<span class="sd">        </span>
<span class="sd">        This calculation is based on the :meth:`interpolate` function and the :func:`np.histogram` function, both of which are not quite vector-fast, but are sufficiently fast for most purposes. This method has been tested to be much faster than :meth:`integrate_quad`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">wavelengths</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">wavelengths</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wavelengths</span>
        <span class="k">if</span> <span class="n">wavelengths</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">u&quot;Requires Wavelenths&quot;</span><span class="p">)</span>
        
        <span class="c"># Upsample the provided wavelengths</span>
        <span class="c"># This increases the accuracy of the trapezoidal algorithm, as this algorithm is very sensitive to sampling errors.</span>
        <span class="k">if</span> <span class="n">upscale</span> <span class="o">!=</span> <span class="mf">1.0</span><span class="p">:</span>
            <span class="n">startindexs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">wavelengths</span><span class="o">.</span><span class="n">size</span><span class="p">)</span> <span class="o">*</span> <span class="n">upscale</span>
            <span class="n">func</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span><span class="n">startindexs</span><span class="p">,</span><span class="n">wavelengths</span><span class="p">)</span>
            <span class="n">findindexs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">startindexs</span><span class="p">))</span>
            <span class="n">bins</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">findindexs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">bins</span> <span class="o">=</span> <span class="n">wavelengths</span>
        
        <span class="c"># Data sanity check</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">u&quot;Interpolating to wavelength bins.&quot;</span><span class="p">)</span>
        <span class="n">oldwl</span><span class="p">,</span><span class="n">oldfl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">interpolate</span><span class="p">(</span><span class="n">wavelengths</span><span class="o">=</span><span class="n">bins</span><span class="p">,</span><span class="n">extrapolate</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">u&quot;Integration Starting&quot;</span><span class="p">)</span>
        
        <span class="n">error</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">warning</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="n">arrays</span> <span class="o">=</span> <span class="p">{}</span>
                
        <span class="k">if</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">bins</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s">u&quot;λ Bins must increase monotonically. [wl + </span><span class="si">%g</span><span class="s">]&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">wavelengths</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">wavelengths</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">arrays</span> <span class="o">=</span> <span class="p">{</span><span class="s">u&quot;λ Bins&quot;</span> <span class="p">:</span> <span class="n">bins</span><span class="p">,</span> <span class="s">u&quot;Requested λ&quot;</span> <span class="p">:</span> <span class="n">wavelengths</span> <span class="p">,</span><span class="s">u&quot;Requested Δλ&quot;</span><span class="p">:</span> <span class="n">wavelengths</span><span class="p">,</span> <span class="s">u&quot;Bin Δλ&quot;</span> <span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">bins</span><span class="p">),</span><span class="s">u&quot;λ Offset&quot;</span> <span class="p">:</span> <span class="n">offset</span> <span class="p">}</span>
            <span class="n">error</span> <span class="o">=</span> <span class="ne">ValueError</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">bincount</span><span class="p">,</span><span class="n">wavelengths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">oldwl</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">wavelengths</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">bincount</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s">u&quot;Given λ is undersampled in Requested λ (there is not at least 1 given λ per requested bin)&quot;</span>
                <span class="n">arrays</span> <span class="o">=</span> <span class="p">{</span><span class="s">u&quot;Histogram of λ&quot;</span> <span class="p">:</span> <span class="n">bincount</span><span class="p">,</span> <span class="s">u&quot;Requested λ&quot;</span> <span class="p">:</span> <span class="n">wavelengths</span> <span class="p">,</span> <span class="s">u&quot;Given λ&quot;</span> <span class="p">:</span> <span class="n">oldwl</span> <span class="p">}</span>
                <span class="n">error</span> <span class="o">=</span> <span class="ne">ValueError</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">bincount</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="s">u&quot;Bins appear undersampled by given λ&quot;</span>
                <span class="n">arrays</span> <span class="o">=</span> <span class="p">{</span><span class="s">u&quot;Histogram of λ&quot;</span> <span class="p">:</span> <span class="n">bincount</span><span class="p">,</span> <span class="s">u&quot;Requested λ&quot;</span> <span class="p">:</span> <span class="n">wavelengths</span> <span class="p">,</span> <span class="s">u&quot;Given λ&quot;</span> <span class="p">:</span> <span class="n">oldwl</span> <span class="p">}</span>
                <span class="n">warning</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_presanity</span><span class="p">(</span><span class="n">oldwl</span><span class="p">,</span><span class="n">oldfl</span><span class="p">,</span><span class="n">wavelengths</span><span class="p">,</span><span class="n">error</span><span class="o">=</span><span class="n">error</span><span class="p">,</span><span class="n">message</span><span class="o">=</span><span class="n">msg</span><span class="p">,</span><span class="n">warning</span><span class="o">=</span><span class="n">warning</span><span class="p">,</span><span class="n">extrapolate</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="o">**</span><span class="n">arrays</span><span class="p">)</span>
        
        <span class="n">wlStart</span> <span class="o">=</span> <span class="n">wavelengths</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">wlEnd</span> <span class="o">=</span> <span class="n">wavelengths</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>         
        
        <span class="n">w</span> <span class="o">=</span> <span class="p">(</span><span class="n">oldwl</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">-</span><span class="n">oldwl</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="p">(</span><span class="n">oldfl</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">+</span><span class="n">oldfl</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span>
        
        <span class="n">flux</span><span class="p">,</span> <span class="n">bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">oldwl</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">wavelengths</span><span class="p">,</span><span class="n">weights</span><span class="o">=</span><span class="n">w</span><span class="p">)</span>
        <span class="n">flux</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">flux</span><span class="p">,</span><span class="n">flux</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
        
        <span class="c"># This is our sanity check. Everything we calculated should be a number. If it comes out as nan, then we have done something wrong.</span>
        <span class="c"># In that case, we raise an error after printing information about the whole calculation.</span>
        <span class="n">arrays</span> <span class="o">=</span> <span class="p">{</span> <span class="s">u&quot;Requested lower bound λ&quot;</span> <span class="p">:</span> <span class="n">wlStart</span> <span class="p">,</span> <span class="s">u&quot;Requested upper bound λ&quot;</span> <span class="p">:</span> <span class="n">wlEnd</span> <span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_postsanity</span><span class="p">(</span><span class="n">oldwl</span><span class="p">,</span><span class="n">oldfl</span><span class="p">,</span><span class="n">wavelengths</span><span class="p">,</span><span class="n">flux</span><span class="p">,</span><span class="n">extrapolate</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span><span class="o">**</span><span class="n">arrays</span><span class="p">)</span>
        <span class="c"># We do print fun information about the final calculation regardless.</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">u&quot;</span><span class="si">%s</span><span class="s">: </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">npArrayInfo</span><span class="p">(</span><span class="n">flux</span><span class="p">,</span><span class="s">&quot;New Flux&quot;</span><span class="p">)))</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">u&quot;Integration Complete&quot;</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">wavelengths</span><span class="p">,</span><span class="n">flux</span><span class="p">))</span>
    
    
    <span class="k">def</span> <span class="nf">integrate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calls the default integrator.&quot;&quot;&quot;</span>
        <span class="n">method</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">default_integrator</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">method</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
    
    <span class="k">def</span> <span class="nf">integrate_quad</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">wavelengths</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">intSteps</span><span class="o">=</span><span class="mi">150</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Performs an integration along wavelengths using the scipy QUADpack implementation in :func:`scipy.integrate.quad`. </span>
<span class="sd">        </span>
<span class="sd">        Input should be a set of wavelengths requested for the system (in the `wavelengths` keyword). The output will be a data array of wavelengths and fluxes (should be the provided `wavelengths`, and an equivalently shaped array with fluxes.)</span>
<span class="sd">        </span>
<span class="sd">        This integrator uses a generator based for-loop wraped around a call to :func:`scipy.integrate.quad`. On an operation with ~100 elements, this operation can consume close to 20s of computation time. Also, this method must stay strictly within the provided wavelength data. The `intSteps` keyword controls the maximum number of steps in each integration. Turning this value down speeds up the integrator.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">wavelengths</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">wavelengths</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wavelengths</span>
        <span class="k">if</span> <span class="n">wavelengths</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s">u&quot;Requires Wavelenths&quot;</span><span class="p">)</span>
        
        <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">u&quot;Integration Starting&quot;</span><span class="p">)</span>
        
        
        <span class="c"># Data sanity check</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_presanity</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wavelengths</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">flux</span><span class="p">,</span><span class="n">wavelengths</span><span class="p">)</span>
        
        <span class="bp">self</span><span class="o">.</span><span class="n">func</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wavelengths</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">flux</span><span class="p">,</span><span class="n">bounds_error</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        
        <span class="n">wlStart</span> <span class="o">=</span> <span class="n">wavelengths</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">wlEnd</span> <span class="o">=</span> <span class="n">wavelengths</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>         
        
        <span class="n">flux</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span> <span class="n">sp</span><span class="o">.</span><span class="n">integrate</span><span class="o">.</span><span class="n">quad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">func</span><span class="p">,</span><span class="n">wlS</span><span class="p">,</span><span class="n">wlE</span><span class="p">,</span><span class="n">limit</span><span class="o">=</span><span class="n">intSteps</span><span class="p">,</span><span class="n">full_output</span><span class="o">=</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">wlS</span><span class="p">,</span><span class="n">wlE</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">wlStart</span><span class="p">,</span><span class="n">wlEnd</span><span class="p">)</span> <span class="p">])</span>
        <span class="n">flux</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">((</span><span class="n">flux</span><span class="p">,</span><span class="n">flux</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
        
        <span class="c"># This is our sanity check. Everything we calculated should be a number. If it comes out as nan, then we have done something wrong.</span>
        <span class="c"># In that case, we raise an error after printing information about the whole calculation.</span>
        <span class="n">arrays</span> <span class="o">=</span> <span class="p">{</span> <span class="s">u&quot;Requested lower bound λ&quot;</span> <span class="p">:</span> <span class="n">wlStart</span> <span class="p">,</span> <span class="s">u&quot;Requested upper bound λ&quot;</span> <span class="p">:</span> <span class="n">wlEnd</span> <span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_postsanity</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wavelengths</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">flux</span><span class="p">,</span><span class="n">wavelengths</span><span class="p">,</span><span class="n">flux</span><span class="p">,</span><span class="o">**</span><span class="n">arrays</span><span class="p">)</span>

        <span class="c"># We do print fun information about the final calculation regardless.</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">u&quot;</span><span class="si">%s</span><span class="s">: </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">npArrayInfo</span><span class="p">(</span><span class="n">flux</span><span class="p">,</span><span class="s">&quot;New Flux&quot;</span><span class="p">)))</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">u&quot;Integration Complete&quot;</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">wavelengths</span><span class="p">,</span><span class="n">flux</span><span class="p">))</span>
    
    <span class="k">def</span> <span class="nf">resolve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">wavelengths</span><span class="p">,</span><span class="n">resolution</span><span class="p">,</span><span class="n">resolve_method</span><span class="o">=</span><span class="s">&#39;resample&#39;</span><span class="p">,</span><span class="n">upscaling</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This method calls a spectrum method, saving and returning the result. The saved data is prepared for the :meth:`resolve_and_integrate` function before being returned. The method also prevents over-resolution sampling.</span>
<span class="sd">        </span>
<span class="sd">        The resolution provided (`resolution` keyword) are used to request a resampled resolution. However, to prevent information loss, by default (see the `upscaling` keyword) the method automatically prevents the new resolution from exceeding the inherent resolution of the provided data. This allows the system to request a high resolution spectrum, and instead receive the maximum amount of information available at every point.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">resolver</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">resolve_method</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">resolve_method</span> <span class="o">=</span> <span class="n">resolve_method</span>
        <span class="n">newwl</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">wavelengths</span><span class="p">)</span>
        <span class="n">newrs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">resolution</span><span class="p">)</span>
        <span class="n">oldwl</span><span class="p">,</span><span class="n">oldfl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>
        <span class="n">oldrs</span> <span class="o">=</span>  <span class="n">oldwl</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">oldwl</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="ow">not</span> <span class="n">upscaling</span><span class="p">:</span>        
            <span class="n">upsample</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="n">oldrsf</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span><span class="n">oldwl</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">oldrs</span><span class="p">,</span><span class="n">bounds_error</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span><span class="n">fill_value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">oldrs</span><span class="p">))</span>
            <span class="n">oldrsd</span> <span class="o">=</span> <span class="n">oldrsf</span><span class="p">(</span><span class="n">newwl</span><span class="p">)</span>
            <span class="n">delrs</span> <span class="o">=</span> <span class="n">newrs</span> <span class="o">&gt;</span> <span class="n">oldrsd</span>
            <span class="n">newrs</span><span class="p">[</span><span class="n">delrs</span><span class="p">]</span> <span class="o">=</span> <span class="n">oldrsd</span><span class="p">[</span><span class="n">delrs</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">upsample</span> <span class="o">=</span> <span class="bp">True</span>
            
        
        <span class="c"># Save the original data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">original_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span>
        
        <span class="c"># Do the actual integration, and save it to the object.</span>
        <span class="n">dwl</span><span class="p">,</span><span class="n">dfl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">resolver</span><span class="p">(</span><span class="n">wavelengths</span><span class="o">=</span><span class="n">newwl</span><span class="p">,</span><span class="n">resolution</span><span class="o">=</span><span class="n">newrs</span><span class="p">,</span><span class="n">upsample</span><span class="o">=</span><span class="n">upsample</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">resolved_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">dwl</span><span class="p">,</span><span class="n">dfl</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">resolved</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">resolved_data</span>
        
                
    <span class="k">def</span> <span class="nf">resolve_and_integrate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">wavelengths</span><span class="p">,</span><span class="n">resolution</span><span class="p">,</span><span class="n">resolve_method</span><span class="o">=</span><span class="s">&#39;resample&#39;</span><span class="p">,</span><span class="n">integration_method</span><span class="o">=</span><span class="s">&#39;integrate_hist&#39;</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Resolve a spectrum at a given resolution once, and use that resolved resolution for integration in the future.</span>
<span class="sd">        </span>
<span class="sd">        The spectrum is first resolved by the :meth:`resolve` function. This provides an appropriately resampled spectrum for use with the integrator. The integrator is then called, and used to get a result. The data from the :meth:`resolve` function is saved for future use.</span>
<span class="sd">        </span>
<span class="sd">        Input should be a set of wavelengths requested for the system (in the `wavelengths` keyword) and an array of resolutions requested in the `resolutions` keyword. The output will be a data array of wavelengths and fluxes (should be the provided `wavelengths`, and an equivalently shaped array with fluxes.)</span>
<span class="sd">        </span>
<span class="sd">        .. Note :: The speedup advantage of this method is only beneficial for large data arrays, where the :meth:`resample` function is slow. However, it also allows the use of resample and integrate simultaneously. As such, there is essentially no downside to using this method over a UnitarySpectrum call to insert another interpolation method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        
        <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">u&quot;Resolve and Resample Starting&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s">&#39;resolved&#39;</span><span class="p">):</span>
            <span class="n">txt</span> <span class="o">=</span> <span class="s">u&quot;Resolved using </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">resolve_method</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">resolved</span> <span class="k">else</span> <span class="s">&quot;Resolving using </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">resolve_method</span>
            <span class="c"># Test resolution for current validity:</span>
            <span class="n">bincount</span><span class="p">,</span><span class="n">bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wavelengths</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">wavelengths</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">bincount</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="n">txt</span> <span class="o">=</span> <span class="s">u&quot;Re-resolving using </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">resolve_method</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">resolved</span> <span class="o">=</span> <span class="bp">False</span>            
            <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">u&quot;</span><span class="si">%s</span><span class="s">: </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">txt</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">resolved</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">u&quot;</span><span class="si">%s</span><span class="s">: </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="s">&quot;Resolving first using </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">resolve_method</span><span class="p">))</span>
        
        <span class="c"># First pass resolving the spectrum to a denser data set.</span>
        <span class="c"># This pass uses the upscaling parameter to find a much denser resolution.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">resolved</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">resolve</span><span class="p">(</span><span class="n">wavelengths</span><span class="o">=</span><span class="n">wavelengths</span><span class="p">,</span><span class="n">resolution</span><span class="o">=</span><span class="n">resolution</span><span class="p">,</span><span class="n">resolve_method</span><span class="o">=</span><span class="n">resolve_method</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        
        <span class="n">LOG</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s">&quot;Integrating using </span><span class="si">%s</span><span class="s">&quot;</span> <span class="o">%</span> <span class="n">integration_method</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">integrator</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">integration_method</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">resolved_data</span>
        <span class="n">integrated</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">integrator</span><span class="p">(</span><span class="n">wavelengths</span><span class="o">=</span><span class="n">wavelengths</span><span class="p">,</span><span class="n">resolution</span><span class="o">=</span><span class="n">resolution</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">original_data</span>
        <span class="k">return</span> <span class="n">integrated</span>
        

<div class="viewcode-block" id="InterpolatedSpectrum"><a class="viewcode-back" href="../../AnalyticSpectra.html#AstroObject.AnalyticSpectra.InterpolatedSpectrum">[docs]</a><span class="k">class</span> <span class="nc">InterpolatedSpectrum</span><span class="p">(</span><span class="n">AstroSpectra</span><span class="o">.</span><span class="n">SpectraFrame</span><span class="p">,</span><span class="n">InterpolatedSpectrumBase</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;An analytic representation of a generic, specified spectrum. The spectrum provided will be used to create an infintiely dense interpolation function. This function can then be used to call the spectrum at any wavelength. The interpolation used by default is a simple 1d interpolation.</span>
<span class="sd">    </span>
<span class="sd">    Passing the name of any member function in this class to the `method` parameter will change the interpolation/method used for this spectrum.</span>
<span class="sd">    </span>
<span class="sd">    .. inheritance-diagram::</span>
<span class="sd">        AstroObject.AnalyticSpectra.InterpolatedSpectrum</span>
<span class="sd">        :parts: 1</span>
<span class="sd">        </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>    
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">size</span> <span class="c"># The size of this image</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span> <span class="c"># The shape of this image</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">InterpolatedSpectrum</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span><span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        
<div class="viewcode-block" id="InterpolatedSpectrum.__call__"><a class="viewcode-back" href="../../AnalyticSpectra.html#AstroObject.AnalyticSpectra.InterpolatedSpectrum.__call__">[docs]</a>    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">method</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calls this interpolated spectrum over certain wavelengths. The `method` parameter will default to the one set for the object, and controls the method used to interpret this spectrum. Available methods include all members of :class:`InterpolatedSpectrum` which provide return values (all those documented below).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">InterpolatedSpectrumBase</span><span class="o">.</span><span class="n">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c"># This call explicitly overrides MRO for this class, as a workaround.</span>
        <span class="c"># Simply put, we want SpectraFrame calls to show up before AnalyticSpectrum, so that __hdu__ and __show__ etc</span>
        <span class="c"># end up pulled from the SpectraFrame, and then __call__ gets pulled from InterpolatedSpectrumBase</span>
        <span class="c"># This allows a custom __call__ function for extraction of interpolated spectral data withouth the difficulties caused by MROs</span>
    
</div></div>
<div class="viewcode-block" id="Resolver"><a class="viewcode-back" href="../../AnalyticSpectra.html#AstroObject.AnalyticSpectra.Resolver">[docs]</a><span class="k">class</span> <span class="nc">Resolver</span><span class="p">(</span><span class="n">AstroSpectra</span><span class="o">.</span><span class="n">SpectraFrame</span><span class="p">,</span><span class="n">InterpolatedSpectrumBase</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This spectrum performs a unitary operation on any InterpolatedSpectrum-type-object. The operation (specified by the `method` keyword) is performed after the contained spectrum is called. The included spectrum is called immediately and then discarded. As such, wavelength and resolution keywords should be provided when appropriate to resolve the spectrum immediately. This operation does not save the old data state. All methods in :class:`InterpolatedSpectrum` are available.</span>
<span class="sd">    </span>
<span class="sd">    .. inheritance-diagram::</span>
<span class="sd">        AstroObject.AnalyticSpectra.Resolver</span>
<span class="sd">        :parts: 1</span>
<span class="sd">        </span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spectrum</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">new_method</span><span class="o">=</span><span class="s">&#39;interpolate&#39;</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        
        <span class="c"># Priority grabbing of Spectra</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">spectrum</span><span class="p">,</span><span class="n">AstroObjectBase</span><span class="o">.</span><span class="n">BaseFrame</span><span class="p">):</span>
            <span class="c"># First assume everything is a spectrum</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">spectrum</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">spectrum</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">spectrum</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">&#39;data&#39;</span><span class="p">,</span><span class="bp">None</span><span class="p">),</span><span class="n">AstroObjectBase</span><span class="o">.</span><span class="n">BaseFrame</span><span class="p">):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;data&#39;</span><span class="p">,</span><span class="bp">None</span><span class="p">)(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;data&#39;</span><span class="p">,</span><span class="bp">None</span><span class="p">)</span>
                
        <span class="k">if</span> <span class="ow">not</span> <span class="n">label</span><span class="p">:</span>
            <span class="n">label</span> <span class="o">=</span>  <span class="s">u&quot;R[&quot;</span> <span class="o">+</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">label</span> <span class="o">+</span> <span class="s">&quot;]&quot;</span>
        
        <span class="nb">super</span><span class="p">(</span><span class="n">Resolver</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span><span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">,</span><span class="n">method</span><span class="o">=</span><span class="n">new_method</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        
<div class="viewcode-block" id="Resolver.__call__"><a class="viewcode-back" href="../../AnalyticSpectra.html#AstroObject.AnalyticSpectra.Resolver.__call__">[docs]</a>    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">method</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calls this interpolated spectrum over certain wavelengths. The `method` parameter will default to the one set for the object, and controls the method used to interpret this spectrum. Available methods include all members of :class:`InterpolatedSpectrum` which provide return values (all those documented below).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">InterpolatedSpectrumBase</span><span class="o">.</span><span class="n">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c"># This call explicitly overrides MRO for this class, as a workaround.</span>
        <span class="c"># Simply put, we want SpectraFrame calls to show up before AnalyticSpectrum, so that __hdu__ and __show__ etc</span>
        <span class="c"># end up pulled from the SpectraFrame, and then __call__ gets pulled from InterpolatedSpectrumBase</span>
        <span class="c"># This allows a custom __call__ function for extraction of interpolated spectral data withouth the difficulties caused by MROs</span>
        
    
        </div></div>
<div class="viewcode-block" id="UnitarySpectrum"><a class="viewcode-back" href="../../AnalyticSpectra.html#AstroObject.AnalyticSpectra.UnitarySpectrum">[docs]</a><span class="k">class</span> <span class="nc">UnitarySpectrum</span><span class="p">(</span><span class="n">AstroObjectBase</span><span class="o">.</span><span class="n">AnalyticMixin</span><span class="p">,</span><span class="n">AstroSpectra</span><span class="o">.</span><span class="n">SpectraMixin</span><span class="p">,</span><span class="n">InterpolatedSpectrumBase</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This spectrum performs a unitary operation on any InterpolatedSpectrum-type-object. The operation (specified by the `method` keyword) is performed after the contained spectrum is called. All methods in :class:`InterpolatedSpectrum` are available.</span>
<span class="sd">    </span>
<span class="sd">    .. inheritance-diagram::</span>
<span class="sd">        AstroObject.AnalyticSpectra.UnitarySpectrum</span>
<span class="sd">        :parts: 1</span>
<span class="sd">        </span>
<span class="sd">    </span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">spectrum</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s">&#39;interpolate&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">spectrum</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">spectrum</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s">&#39;data&#39;</span><span class="p">,</span><span class="bp">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">label</span><span class="p">:</span>
            <span class="n">label</span> <span class="o">=</span>  <span class="s">u&quot;[&quot;</span> <span class="o">+</span> <span class="n">spectrum</span><span class="o">.</span><span class="n">label</span> <span class="o">+</span> <span class="s">u&quot;]&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">spectrum</span> <span class="o">=</span> <span class="n">spectrum</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">UnitarySpectrum</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        
<div class="viewcode-block" id="UnitarySpectrum.__call__"><a class="viewcode-back" href="../../AnalyticSpectra.html#AstroObject.AnalyticSpectra.UnitarySpectrum.__call__">[docs]</a>    <span class="k">def</span> <span class="nf">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">old_method</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="n">method</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calls this interpolated spectrum over certain wavelengths. The `method` parameter will default to the one set for the object, and controls the method used to interpret this spectrum. The `old_method` parameter will be used on the contained spectrum. Available methods include all members of :class:`InterpolatedSpectrum` which provide return values (all those documented below).&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectrum</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="n">old_method</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">InterpolatedSpectrumBase</span><span class="o">.</span><span class="n">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c"># This call explicitly overrides MRO for this class, as a workaround.</span>
        <span class="c"># Simply put, we want SpectraFrame calls to show up before AnalyticSpectrum, so that __hdu__ and __show__ etc</span>
        <span class="c"># end up pulled from the SpectraFrame, and then __call__ gets pulled from InterpolatedSpectrumBase</span>
        <span class="c"># This allows a custom __call__ function for extraction of interpolated spectral data withouth the difficulties caused by MROs</span>
</div>
    <span class="k">def</span> <span class="nf">__valid__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Check our unitary spectrum for validity&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spectrum</span><span class="p">,</span><span class="n">AstroObjectBase</span><span class="o">.</span><span class="n">BaseFrame</span><span class="p">),</span> <span class="s">&quot;Unitary Spectrum must contain another spectrum&quot;</span>
        <span class="k">assert</span> <span class="nb">callable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">),</span> <span class="s">&quot;Method must be a callable object.&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">UnitarySpectrum</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__valid__</span><span class="p">()</span>
        
                    
</div>
<span class="kn">import</span> <span class="nn">AnalyticSpectraObjects</span>
<span class="kn">from</span> <span class="nn">AnalyticSpectraObjects</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">__all__</span> <span class="o">+=</span> <span class="n">AnalyticSpectraObjects</span><span class="o">.</span><span class="n">__all__</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li><a href="../../index.html">AstroObject 0.5.3 documentation</a> &raquo;</li>
          <li><a href="../index.html" >Module code</a> &raquo;</li>
          <li><a href="../AstroObject.html" >AstroObject</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2011, Alexander Rudy.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>