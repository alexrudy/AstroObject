

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>8. Analytic Spectra and Interpolation AnalyticSpectra &mdash; AstroObject 0.3.0 documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '0.3.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="AstroObject 0.3.0 documentation" href="index.html" />
    <link rel="next" title="9. HDU Objects and Storage AstroFITS" href="AstroFITS.html" />
    <link rel="prev" title="7. Raw Spectrum Management AstroSpectra" href="AstroSpectra.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="AstroFITS.html" title="9. HDU Objects and Storage AstroFITS"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="AstroSpectra.html" title="7. Raw Spectrum Management AstroSpectra"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">AstroObject 0.3.0 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <span class="target" id="module-AstroObject.AnalyticSpectra"></span><div class="section" id="analytic-spectra-and-interpolation-analyticspectra">
<h1>8. Analytic Spectra and Interpolation <tt class="xref py py-mod docutils literal"><span class="pre">AnalyticSpectra</span></tt><a class="headerlink" href="#analytic-spectra-and-interpolation-analyticspectra" title="Permalink to this headline">¶</a></h1>
<p>Objects for manipulating and managing spectra which are inherently analytic (i.e. you want interpolation, or your spectrum to be defined by a single function). The classes provided in this module are <em>FRAMES</em> not <em>OBJECTS</em>, i.e. they are individual representations of spectra etc.</p>
<p>It is possible to create an AnalyticSpectraObject to hold many spectra. However, such an object might be of limited utility, as it could not be used to write or read data saved in FITS files, as the FITS format is not conducive to storing analytic items.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This is a solvable problem. I could use FITS header information to store the required values for an analytic spectrum, and then simply store empty images. However, I don&#8217;t need this capability now, so maybe in a future version.</p>
</div>
<p>This module contains a few pre-defined analytic spectra which you can use as examples. See the <tt class="xref py py-mod docutils literal"><span class="pre">AnalyticSpectraObjects</span></tt> module.</p>
<p>This module provides basic analytic spectrum capabilites. There is a simple principle at work in this module: Do all calculations as late as possible. As such, most spectra will be defined as basic analytic spectra. However, the use of the <a class="reference internal" href="#AstroObject.AnalyticSpectra.CompositeSpectra" title="AstroObject.AnalyticSpectra.CompositeSpectra"><tt class="xref py py-class docutils literal"><span class="pre">CompositeSpectra</span></tt></a> class allows spectra to be used in mathematics:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">A</span> <span class="o">=</span> <span class="n">AnalyticSpectrum</span><span class="p">()</span>
<span class="n">B</span> <span class="o">=</span> <span class="n">AnaltyicSpectrum</span><span class="p">()</span>
<span class="n">C</span> <span class="o">=</span> <span class="n">A</span> <span class="o">+</span> <span class="n">B</span> <span class="o">*</span> <span class="mi">20</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">I believe that STSCI Python has some spectrum capabilities, and I am researching combining this module to provide adaptors for the STSCI implementation.</p>
</div>
<dl class="class">
<dt id="AstroObject.AnalyticSpectra.AnalyticSpectrum">
<em class="property">class </em><tt class="descclassname">AstroObject.AnalyticSpectra.</tt><tt class="descname">AnalyticSpectrum</tt><big>(</big><em>data=None</em>, <em>label=None</em>, <em>wavelengths=None</em>, <em>units=None</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/AstroObject/AnalyticSpectra.html#AnalyticSpectrum"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#AstroObject.AnalyticSpectra.AnalyticSpectrum" title="Permalink to this definition">¶</a></dt>
<dd><p>A functional spectrum object for spe ctrum generation. The default implementation is a flat spectrum.</p>
<p>The Analytic spectrum can be provided with a set of wavelengths upon intialization. The <cite>wavelengths</cite> keyword will be stored and used when this spectrum is later called by the system. The <cite>units</cite> keyword is currently unused.</p>
<dl class="method">
<dt id="AstroObject.AnalyticSpectra.AnalyticSpectrum.__add__">
<tt class="descname">__add__</tt><big>(</big><em>other</em><big>)</big><a class="reference internal" href="_modules/AstroObject/AnalyticSpectra.html#AnalyticSpectrum.__add__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#AstroObject.AnalyticSpectra.AnalyticSpectrum.__add__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implements spectrum addition</p>
</dd></dl>

<dl class="method">
<dt id="AstroObject.AnalyticSpectra.AnalyticSpectrum.__mul__">
<tt class="descname">__mul__</tt><big>(</big><em>other</em><big>)</big><a class="reference internal" href="_modules/AstroObject/AnalyticSpectra.html#AnalyticSpectrum.__mul__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#AstroObject.AnalyticSpectra.AnalyticSpectrum.__mul__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implements spectrum multiplication</p>
</dd></dl>

<dl class="method">
<dt id="AstroObject.AnalyticSpectra.AnalyticSpectrum.__radd__">
<tt class="descname">__radd__</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/AstroObject/AnalyticSpectra.html#AnalyticSpectrum.__radd__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#AstroObject.AnalyticSpectra.AnalyticSpectrum.__radd__" title="Permalink to this definition">¶</a></dt>
<dd><p>Reverse Addition</p>
</dd></dl>

<dl class="method">
<dt id="AstroObject.AnalyticSpectra.AnalyticSpectrum.__rmul__">
<tt class="descname">__rmul__</tt><big>(</big><big>)</big><a class="reference internal" href="_modules/AstroObject/AnalyticSpectra.html#AnalyticSpectrum.__rmul__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#AstroObject.AnalyticSpectra.AnalyticSpectrum.__rmul__" title="Permalink to this definition">¶</a></dt>
<dd><p>Reverse Multiplication</p>
</dd></dl>

<dl class="method">
<dt id="AstroObject.AnalyticSpectra.AnalyticSpectrum.__rsub__">
<tt class="descname">__rsub__</tt><big>(</big><em>other</em><big>)</big><a class="reference internal" href="_modules/AstroObject/AnalyticSpectra.html#AnalyticSpectrum.__rsub__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#AstroObject.AnalyticSpectra.AnalyticSpectrum.__rsub__" title="Permalink to this definition">¶</a></dt>
<dd><p>Reverse subtraction</p>
</dd></dl>

<dl class="method">
<dt id="AstroObject.AnalyticSpectra.AnalyticSpectrum.__sub__">
<tt class="descname">__sub__</tt><big>(</big><em>other</em><big>)</big><a class="reference internal" href="_modules/AstroObject/AnalyticSpectra.html#AnalyticSpectrum.__sub__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#AstroObject.AnalyticSpectra.AnalyticSpectrum.__sub__" title="Permalink to this definition">¶</a></dt>
<dd><p>Implements spectrum subtraction</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="AstroObject.AnalyticSpectra.CompositeSpectra">
<em class="property">class </em><tt class="descclassname">AstroObject.AnalyticSpectra.</tt><tt class="descname">CompositeSpectra</tt><big>(</big><em>partA</em>, <em>partB</em>, <em>operation</em><big>)</big><a class="reference internal" href="_modules/AstroObject/AnalyticSpectra.html#CompositeSpectra"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#AstroObject.AnalyticSpectra.CompositeSpectra" title="Permalink to this definition">¶</a></dt>
<dd><p>Binary composition of two functional spectra. This object should not be initialized by the user. Instead, this class is returned when you combine two spectra of different types, or combine a spectra with any other type. As such, do not initialze composite spectra idependently. See the <a class="reference internal" href="#AstroObject.AnalyticSpectra.CompositeSpectra.__call__" title="AstroObject.AnalyticSpectra.CompositeSpectra.__call__"><tt class="xref py py-meth docutils literal"><span class="pre">__call__()</span></tt></a> function for documentation of how to use this type of object.</p>
<dl class="method">
<dt id="AstroObject.AnalyticSpectra.CompositeSpectra.__call__">
<tt class="descname">__call__</tt><big>(</big><em>wavelengths=None</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/AstroObject/AnalyticSpectra.html#CompositeSpectra.__call__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#AstroObject.AnalyticSpectra.CompositeSpectra.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Calls the composite function components. The keyword arguments are passed on to calls to spectra contained within this composite spectra. All spectra varieties should accept arbitrary keywords, so this argument is used to pass keywords to spectra which require specific alternatives. Pass in <cite>wavelengths</cite> to use the given wavelengths. If none are passed in, it will look for object-level saved wavelengths, which you can specify simply by setting the <cite>self.wavelengths</cite> parameter on the object.</p>
</dd></dl>

</dd></dl>

<div class="section" id="expansion-objects">
<h2>8.1. Expansion Objects<a class="headerlink" href="#expansion-objects" title="Permalink to this headline">¶</a></h2>
<p>These objects expand the concept of an analytic spectrum to be any spectrum which can respond to calls with arbitrary wavelength boundaries. The spectra in the InterpolatedSpectrum class can be triggered to respond as if they are infintely dense FLambda spectra, or as if they require resampling from one resolution to another. Finally, such spectra can be used as a 1-dimensional interpolation function.</p>
<dl class="class">
<dt id="AstroObject.AnalyticSpectra.InterpolatedSpectrum">
<em class="property">class </em><tt class="descclassname">AstroObject.AnalyticSpectra.</tt><tt class="descname">InterpolatedSpectrum</tt><big>(</big><em>data=None</em>, <em>label=None</em>, <em>wavelengths=None</em>, <em>resolution=None</em>, <em>intSteps=150</em>, <em>method='interpolate'</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/AstroObject/AnalyticSpectra.html#InterpolatedSpectrum"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#AstroObject.AnalyticSpectra.InterpolatedSpectrum" title="Permalink to this definition">¶</a></dt>
<dd><p>An analytic representation of a generic, specified spectrum. The spectrum provided will be used to create an infintiely dense interpolation function. This function can then be used to call the spectrum at any wavelength. The interpolation used by default is a simple 1d interpolation.</p>
<p>Passing the name of any member function in this class to the <cite>method</cite> parameter will change the interpolation/method used for this spectrum.</p>
<dl class="method">
<dt id="AstroObject.AnalyticSpectra.InterpolatedSpectrum.__call__">
<tt class="descname">__call__</tt><big>(</big><em>method=None</em>, <em>**kwargs</em><big>)</big><a class="reference internal" href="_modules/AstroObject/AnalyticSpectra.html#InterpolatedSpectrum.__call__"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#AstroObject.AnalyticSpectra.InterpolatedSpectrum.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Calls this interpolated spectrum over certain wavelengths. The method parameter will default to the one set for the object, and controls the method used to interpret this spectrum.</p>
</dd></dl>

<dl class="method">
<dt id="AstroObject.AnalyticSpectra.InterpolatedSpectrum.integrate">
<tt class="descname">integrate</tt><big>(</big><em>wavelengths=None</em>, <em>resolution=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#AstroObject.AnalyticSpectra.InterpolatedSpectrum.integrate" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs wavelength-integration for flambda spectra.</p>
<p>This takes spectra which have theoretically infinite resolution, and performs an integration using the quadratic pack integrator on an interpolated F_Lambda function. The integration can be a little slow. Sanity checks confirm validity of input data.</p>
</dd></dl>

<dl class="method">
<dt id="AstroObject.AnalyticSpectra.InterpolatedSpectrum.interpolate">
<tt class="descname">interpolate</tt><big>(</big><em>wavelengths=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#AstroObject.AnalyticSpectra.InterpolatedSpectrum.interpolate" title="Permalink to this definition">¶</a></dt>
<dd><p>Uses a 1d Interpolation to fill in missing spectrum values.</p>
<p>This interpolator uses the scipy.interpolate.interp1d method to interpolate between data points in the original spectrum. This method will not handle changes in resolution appropriately.</p>
</dd></dl>

<dl class="method">
<dt id="AstroObject.AnalyticSpectra.InterpolatedSpectrum.pre_resolve">
<tt class="descname">pre_resolve</tt><big>(</big><em>**kwargs</em><big>)</big><a class="headerlink" href="#AstroObject.AnalyticSpectra.InterpolatedSpectrum.pre_resolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Instead of resolving a spectrum at call time, the spectrum can be called to resolve at creation time. In this case, the resolving method uses the raw data values for wavelengths. This pre-computation serves a similar purpose to <a class="reference internal" href="#AstroObject.AnalyticSpectra.InterpolatedSpectrum.resolve_and_resample" title="AstroObject.AnalyticSpectra.InterpolatedSpectrum.resolve_and_resample"><tt class="xref py py-meth docutils literal"><span class="pre">resolve_and_resample()</span></tt></a> but can also be used to collapse large collections of spectra. In the case of collapsing large collections (usually the collections are all constructed, but unresolved <a class="reference internal" href="#AstroObject.AnalyticSpectra.CompositeSpectra" title="AstroObject.AnalyticSpectra.CompositeSpectra"><tt class="xref py py-class docutils literal"><span class="pre">CompositeSpectra</span></tt></a>), the collapse occurs at construction time, removing computation time from other areas of the program.</p>
</dd></dl>

<dl class="method">
<dt id="AstroObject.AnalyticSpectra.InterpolatedSpectrum.resample">
<tt class="descname">resample</tt><big>(</big><em>wavelengths=None</em>, <em>resolution=None</em>, <em>z=0.0</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#AstroObject.AnalyticSpectra.InterpolatedSpectrum.resample" title="Permalink to this definition">¶</a></dt>
<dd><p>Resample the given spectrum to a lower resolution.</p>
<p>This is a vector-based calculation, and so should be relatively fast. This function contains ZERO for loops, and uses entirely numpy-based vector mathematics. Sanity checks try to keep your input clean. It can also redshift a spectrum by a given z parameter, if that is necessary.</p>
</dd></dl>

<dl class="method">
<dt id="AstroObject.AnalyticSpectra.InterpolatedSpectrum.resolve">
<tt class="descname">resolve</tt><big>(</big><em>wavelengths</em>, <em>resolution</em>, <em>upscaling=100.0</em>, <em>resolve_method='integrate'</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#AstroObject.AnalyticSpectra.InterpolatedSpectrum.resolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Oversample underlying spectra.</p>
<p>Using the <cite>resolve_method</cite> method (by default <a class="reference internal" href="#AstroObject.AnalyticSpectra.InterpolatedSpectrum.integrate" title="AstroObject.AnalyticSpectra.InterpolatedSpectrum.integrate"><tt class="xref py py-meth docutils literal"><span class="pre">integrate()</span></tt></a>), this function gets a high resolution copy of the underlying data. The high resolution data can later be downsampled using the <a class="reference internal" href="#AstroObject.AnalyticSpectra.InterpolatedSpectrum.resample" title="AstroObject.AnalyticSpectra.InterpolatedSpectrum.resample"><tt class="xref py py-meth docutils literal"><span class="pre">resample()</span></tt></a> method. This is a faster way to access integrated spectra many times. The speed advantages come over the integrator. By default the system gets 100x the requested resolution. This can be tuned with the <cite>upscaling</cite> keyword to optimize between speed and resolution coverage.</p>
</dd></dl>

<dl class="method">
<dt id="AstroObject.AnalyticSpectra.InterpolatedSpectrum.resolve_and_resample">
<tt class="descname">resolve_and_resample</tt><big>(</big><em>wavelengths</em>, <em>resolution</em>, <em>upscaling=100.0</em>, <em>resolve_method='integrate'</em>, <em>resample_method='resample'</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#AstroObject.AnalyticSpectra.InterpolatedSpectrum.resolve_and_resample" title="Permalink to this definition">¶</a></dt>
<dd><p>Resolve a spectrum at very high resolution, then re-sample down the proper size.</p>
<p>This method reduces the use of computationally intensive integrators in spectral calculation. The intensive integrator is used only on the first pass over the spectrum. The integrator is called at a higher resolution (normally 100x, controlled by the <cite>upscaling</cite> parameter). This higher resolution copy is saved in the object, and downsampled for each request for spectrum information.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="AstroObject.AnalyticSpectra.UnitarySpectrum">
<em class="property">class </em><tt class="descclassname">AstroObject.AnalyticSpectra.</tt><tt class="descname">UnitarySpectrum</tt><big>(</big><em>spectrum</em>, <em>resolution=100.0</em>, <em>method='pre_resolve'</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#AstroObject.AnalyticSpectra.UnitarySpectrum" title="Permalink to this definition">¶</a></dt>
<dd><p>This spectrum calls all contained spectra and resolves them. The resolved spectra are high resolution (using <a class="reference internal" href="#AstroObject.AnalyticSpectra.UnitarySpectrum.pre_resolve" title="AstroObject.AnalyticSpectra.UnitarySpectrum.pre_resolve"><tt class="xref py py-meth docutils literal"><span class="pre">pre_resolve()</span></tt></a> and <a class="reference internal" href="#AstroObject.AnalyticSpectra.UnitarySpectrum.resolve" title="AstroObject.AnalyticSpectra.UnitarySpectrum.resolve"><tt class="xref py py-meth docutils literal"><span class="pre">resolve()</span></tt></a>) and stored for later use. When this spectrum is later called, it will (by default) use <a class="reference internal" href="#AstroObject.AnalyticSpectra.UnitarySpectrum.resolve_and_resample" title="AstroObject.AnalyticSpectra.UnitarySpectrum.resolve_and_resample"><tt class="xref py py-meth docutils literal"><span class="pre">resolve_and_resample()</span></tt></a>.</p>
<dl class="method">
<dt id="AstroObject.AnalyticSpectra.UnitarySpectrum.__call__">
<tt class="descname">__call__</tt><big>(</big><em>method=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#AstroObject.AnalyticSpectra.UnitarySpectrum.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Calls this interpolated spectrum over certain wavelengths. The method parameter will default to the one set for the object, and controls the method used to interpret this spectrum.</p>
</dd></dl>

<dl class="method">
<dt id="AstroObject.AnalyticSpectra.UnitarySpectrum.integrate">
<tt class="descname">integrate</tt><big>(</big><em>wavelengths=None</em>, <em>resolution=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#AstroObject.AnalyticSpectra.UnitarySpectrum.integrate" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs wavelength-integration for flambda spectra.</p>
<p>This takes spectra which have theoretically infinite resolution, and performs an integration using the quadratic pack integrator on an interpolated F_Lambda function. The integration can be a little slow. Sanity checks confirm validity of input data.</p>
</dd></dl>

<dl class="method">
<dt id="AstroObject.AnalyticSpectra.UnitarySpectrum.interpolate">
<tt class="descname">interpolate</tt><big>(</big><em>wavelengths=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#AstroObject.AnalyticSpectra.UnitarySpectrum.interpolate" title="Permalink to this definition">¶</a></dt>
<dd><p>Uses a 1d Interpolation to fill in missing spectrum values.</p>
<p>This interpolator uses the scipy.interpolate.interp1d method to interpolate between data points in the original spectrum. This method will not handle changes in resolution appropriately.</p>
</dd></dl>

<dl class="method">
<dt id="AstroObject.AnalyticSpectra.UnitarySpectrum.pre_resolve">
<tt class="descname">pre_resolve</tt><big>(</big><em>**kwargs</em><big>)</big><a class="headerlink" href="#AstroObject.AnalyticSpectra.UnitarySpectrum.pre_resolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Instead of resolving a spectrum at call time, the spectrum can be called to resolve at creation time. In this case, the resolving method uses the raw data values for wavelengths. This pre-computation serves a similar purpose to <a class="reference internal" href="#AstroObject.AnalyticSpectra.UnitarySpectrum.resolve_and_resample" title="AstroObject.AnalyticSpectra.UnitarySpectrum.resolve_and_resample"><tt class="xref py py-meth docutils literal"><span class="pre">resolve_and_resample()</span></tt></a> but can also be used to collapse large collections of spectra. In the case of collapsing large collections (usually the collections are all constructed, but unresolved <a class="reference internal" href="#AstroObject.AnalyticSpectra.CompositeSpectra" title="AstroObject.AnalyticSpectra.CompositeSpectra"><tt class="xref py py-class docutils literal"><span class="pre">CompositeSpectra</span></tt></a>), the collapse occurs at construction time, removing computation time from other areas of the program.</p>
</dd></dl>

<dl class="method">
<dt id="AstroObject.AnalyticSpectra.UnitarySpectrum.resample">
<tt class="descname">resample</tt><big>(</big><em>wavelengths=None</em>, <em>resolution=None</em>, <em>z=0.0</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#AstroObject.AnalyticSpectra.UnitarySpectrum.resample" title="Permalink to this definition">¶</a></dt>
<dd><p>Resample the given spectrum to a lower resolution.</p>
<p>This is a vector-based calculation, and so should be relatively fast. This function contains ZERO for loops, and uses entirely numpy-based vector mathematics. Sanity checks try to keep your input clean. It can also redshift a spectrum by a given z parameter, if that is necessary.</p>
</dd></dl>

<dl class="method">
<dt id="AstroObject.AnalyticSpectra.UnitarySpectrum.resolve">
<tt class="descname">resolve</tt><big>(</big><em>wavelengths</em>, <em>resolution</em>, <em>upscaling=100.0</em>, <em>resolve_method='integrate'</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#AstroObject.AnalyticSpectra.UnitarySpectrum.resolve" title="Permalink to this definition">¶</a></dt>
<dd><p>Oversample underlying spectra.</p>
<p>Using the <cite>resolve_method</cite> method (by default <a class="reference internal" href="#AstroObject.AnalyticSpectra.UnitarySpectrum.integrate" title="AstroObject.AnalyticSpectra.UnitarySpectrum.integrate"><tt class="xref py py-meth docutils literal"><span class="pre">integrate()</span></tt></a>), this function gets a high resolution copy of the underlying data. The high resolution data can later be downsampled using the <a class="reference internal" href="#AstroObject.AnalyticSpectra.UnitarySpectrum.resample" title="AstroObject.AnalyticSpectra.UnitarySpectrum.resample"><tt class="xref py py-meth docutils literal"><span class="pre">resample()</span></tt></a> method. This is a faster way to access integrated spectra many times. The speed advantages come over the integrator. By default the system gets 100x the requested resolution. This can be tuned with the <cite>upscaling</cite> keyword to optimize between speed and resolution coverage.</p>
</dd></dl>

<dl class="method">
<dt id="AstroObject.AnalyticSpectra.UnitarySpectrum.resolve_and_resample">
<tt class="descname">resolve_and_resample</tt><big>(</big><em>wavelengths</em>, <em>resolution</em>, <em>upscaling=100.0</em>, <em>resolve_method='integrate'</em>, <em>resample_method='resample'</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#AstroObject.AnalyticSpectra.UnitarySpectrum.resolve_and_resample" title="Permalink to this definition">¶</a></dt>
<dd><p>Resolve a spectrum at very high resolution, then re-sample down the proper size.</p>
<p>This method reduces the use of computationally intensive integrators in spectral calculation. The intensive integrator is used only on the first pass over the spectrum. The integrator is called at a higher resolution (normally 100x, controlled by the <cite>upscaling</cite> parameter). This higher resolution copy is saved in the object, and downsampled for each request for spectrum information.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="analytic-spectrum-objects">
<h2>8.2. Analytic Spectrum Objects<a class="headerlink" href="#analytic-spectrum-objects" title="Permalink to this headline">¶</a></h2>
<p>These objects actually have spectral functions included.</p>
<dl class="class">
<dt id="AstroObject.AnalyticSpectra.BlackBodySpectrum">
<em class="property">class </em><tt class="descclassname">AstroObject.AnalyticSpectra.</tt><tt class="descname">BlackBodySpectrum</tt><big>(</big><em>temperature</em>, <em>label=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#AstroObject.AnalyticSpectra.BlackBodySpectrum" title="Permalink to this definition">¶</a></dt>
<dd><p>An analytic representation of a Blackbody Spectrum at a Kelvin Tempertaure</p>
<dl class="method">
<dt id="AstroObject.AnalyticSpectra.BlackBodySpectrum.__call__">
<tt class="descname">__call__</tt><big>(</big><em>wavelengths=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#AstroObject.AnalyticSpectra.BlackBodySpectrum.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Calls this blackbody spectrum over certain wavelengths</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="AstroObject.AnalyticSpectra.GaussianSpectrum">
<em class="property">class </em><tt class="descclassname">AstroObject.AnalyticSpectra.</tt><tt class="descname">GaussianSpectrum</tt><big>(</big><em>mean</em>, <em>stdev</em>, <em>height</em>, <em>label=None</em><big>)</big><a class="headerlink" href="#AstroObject.AnalyticSpectra.GaussianSpectrum" title="Permalink to this definition">¶</a></dt>
<dd><p>An analytic representation of a gaussian function in spectral form</p>
<dl class="method">
<dt id="AstroObject.AnalyticSpectra.GaussianSpectrum.__call__">
<tt class="descname">__call__</tt><big>(</big><em>wavelengths=None</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#AstroObject.AnalyticSpectra.GaussianSpectrum.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Calls this gaussian spectrum over certain wavelengths</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="AstroObject.AnalyticSpectra.FlatSpectrum">
<em class="property">class </em><tt class="descclassname">AstroObject.AnalyticSpectra.</tt><tt class="descname">FlatSpectrum</tt><big>(</big><em>value</em>, <em>label=None</em><big>)</big><a class="headerlink" href="#AstroObject.AnalyticSpectra.FlatSpectrum" title="Permalink to this definition">¶</a></dt>
<dd><p>An analytc form of a flat value at every wavelength</p>
<dl class="method">
<dt id="AstroObject.AnalyticSpectra.FlatSpectrum.__call__">
<tt class="descname">__call__</tt><big>(</big><em>wavelengths</em>, <em>**kwargs</em><big>)</big><a class="headerlink" href="#AstroObject.AnalyticSpectra.FlatSpectrum.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Calls a flat spectrum over given wavelengths</p>
</dd></dl>

</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">8. Analytic Spectra and Interpolation <tt class="docutils literal"><span class="pre">AnalyticSpectra</span></tt></a><ul>
<li><a class="reference internal" href="#expansion-objects">8.1. Expansion Objects</a></li>
<li><a class="reference internal" href="#analytic-spectrum-objects">8.2. Analytic Spectrum Objects</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="AstroSpectra.html"
                        title="previous chapter">7. Raw Spectrum Management <tt class="docutils literal"><span class="pre">AstroSpectra</span></tt></a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="AstroFITS.html"
                        title="next chapter">9. HDU Objects and Storage <tt class="docutils literal"><span class="pre">AstroFITS</span></tt></a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/AnalyticSpectra.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="AstroFITS.html" title="9. HDU Objects and Storage AstroFITS"
             >next</a> |</li>
        <li class="right" >
          <a href="AstroSpectra.html" title="7. Raw Spectrum Management AstroSpectra"
             >previous</a> |</li>
        <li><a href="index.html">AstroObject 0.3.0 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2011, Alexander Rudy.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.2.
    </div>
  </body>
</html>